<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN" lang="zh-CN">
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />

<title>脏标识 &middot; Optimization Patterns &middot; 游戏设计模式</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />
<link href="http://fonts.gmirror.org/css?family=Merriweather:400,400italic,700,700italic|Source+Code+Pro|Source+Sans+Pro:200,300,400,600,400italic,600italic|Rock+Salt" rel="stylesheet" type="text/css">
<!-- delete the google analyse code to improve the speed, sorry. -->
<script src="jquery-1.10.1.min.js"></script>
<script src="script.js"></script>
</head>
<body id="top">
<div class="page sidebar">
<div class="content">
<nav class="top">
  <span class="prev">&larr; <a href="data-locality.html">上一章</a></span>
  <span class="next"><a href="object-pool.html">下一章</a> &rarr;</span>
  <span class="toc">&equiv; <a href="/Game-Programming-Patterns-CN/">首页</a></span>
</nav>
<h1>脏标识</h1>
<h1 class="book"><a href="/Game-Programming-Patterns-CN/">游戏设计模式</a><span class="section"><a href="optimization-patterns.html">Optimization Patterns</a></span></h1>
<h2><a href="#intent" name="intent">Intent</a></h2>
<h2><a href="#意图" name="意图">意图</a></h2>
<p><em>Avoid unnecessary work by deferring it until the result is needed.</em></p>
<p><em>将工作延期至需要其结果时才去执行，避免不必要的工作。</em></p>
<h2><a href="#motivation" name="motivation">Motivation</a></h2>
<h2><a href="#动机" name="动机">动机</a></h2>
<p>Many games have something called a <em>scene graph</em>. This is a big data structure
that contains all of the objects in the world. The rendering engine uses this to
determine where to draw stuff on the screen.</p>
<p>很多游戏有<em>场景图</em>。
那是一个巨大的数据结构，包含了游戏世界中所有的对象。
渲染引擎使用它决定在屏幕哪里画东西。</p>
<p>At its simplest, a scene graph is just a flat list of objects. Each object has a
model, or some other graphic primitive, and a <span
name="transform"><em>transform</em></span>. The transform describes the object&#8217;s
position, rotation, and scale in the world. To move or turn an object, we simply
change its transform.</p>
<p>最简单的实现中，场景图只是对象列表。
每个对象都有模型，或者其他的原始图形，以及<span name="transform"><em>转换</em></span>。
转换描述了对象在世界中的位置，方向，拉伸。
为了移动或者旋转对象，只需简单地改变它的转换。</p>
<aside name="transform">
<p>The mechanics of <em>how</em> this transform is stored and manipulated are unfortunately
out of scope here. The comically abbreviated summary is that it&#8217;s a 4x4 matrix.
You can make a single transform that combines two transforms&#8202;&mdash;&#8202;for example,
translating and then rotating an object&#8202;&mdash;&#8202;by multiplying the two matrices.</p>
<p><em>如何</em>存储和操作转换的机制很不幸超出了本书范围。
一个简单的总结是一个4x4的矩阵。
你可以通过矩阵相乘来组合两个转换，获得单一转换——举个例子，平移之后旋转对象。</p>
<p>How and why that works is left as an exercise for the reader.</p>
<p>它如何工作，以及为什么那样工作是留给读者的练习。</p>
</aside>
<p>When the renderer draws an object, it takes the object&#8217;s model, applies the
transform to it, and then renders it there in the world. If we had a scene
<em>bag</em> and not a scene <em>graph</em>, that would be it, and life would be simple.</p>
<p>当渲染系统描绘对象，它取出对象的模型，对其应用转换，然后将其渲染到游戏世界中。
如果我们有场景<em>包</em>而不是场景<em>图</em>，那就是这样了，生活很简单。</p>
<p>However, most scene graphs are <span name="hierarchical"><em>hierarchical</em></span>.
An object in the graph may have a parent object that it is anchored to. In that
case, its transform is relative to the <em>parent&#8217;s</em> position and isn&#8217;t an
absolute position in the world.</p>
<p>但是，大多数场景图都是<span name="hierarchical"><em>有等级的</em></span>。
图像中的对象也许拥有它锚定的父对象。
这种情况下，它的转换与其<em>父对象</em>的位置相关，不再是游戏世界上的绝对位置。</p>
<p>For example, imagine our game world has a pirate ship at sea. Atop the ship&#8217;s
mast is a crow&#8217;s nest. Hunched in that crow&#8217;s nest is a pirate. Clutching the
pirate&#8217;s shoulder is a parrot. The ship&#8217;s local transform positions the ship in
the sea. The crow&#8217;s nest&#8217;s transform positions the nest on the ship, and so on.</p>
<p>举个例子，将游戏世界想象为海上的海盗船。
桅杆的顶端有瞭望塔，瞭望塔中有海盗，海盗肩上有鹦鹉。
船本身的转换定位船在海上的位置。瞭望塔的转换定位它在船上的位置，诸如此类。</p>
<p><span name="pirate"></span>
<img src="images/dirty-flag-pirate.png" alt="A pirate ship containing a crow's nest with a pirate in it with a parrot on his shoulder." /></p>
<aside name="pirate">
<p>Programmer art!</p>
<p>编程艺术！</p>
</aside>
<p>This way, when a parent object moves, its children move with it automatically.
If we change the local transform of the ship, the crow&#8217;s nest, pirate, and
parrot go along for the ride. It would be a total <span
name="slide">headache</span> if, when the ship moved, we had to manually adjust
the transforms of all the objects on it to keep them from sliding off.</p>
<p>这样的话，当父对象移动时，孩子节点也自动的跟着移动。
如果改变了船自身的转换，瞭望塔，海盗和鹦鹉都会随之移动。
如果当船移动时，就得手动调整每个对象来保证它们不滑出去，那可相当<span name="slide">令人头疼</span>。</p>
<aside name="slide">
<p>To be honest, when you are at sea you <em>do</em> have to keep manually adjusting your
position to keep from sliding off. Maybe I should have chosen a drier example.</p>
<p>老实说，当你在海上，你<em>确实</em>需要手动调整姿势来保证不滑出去。
也许我应该选一个更好的例子。</p>
</aside>
<p>But to actually draw the parrot on screen, we need to know its absolute position
in the world. I&#8217;ll call the parent-relative transform the object&#8217;s <em>local
transform</em>. To render an object, we need to know its <em>world transform</em>.</p>
<p>但是为了在屏幕上真正的描绘鹦鹉，我需要知道它在世界上的绝对位置。
我会调用父节点相关的转换对象的<em>自身转换</em>。
为了渲染一个对象，我需要知道它的<em>世界转换</em>。</p>
<h3><a href="#local-and-world-transforms" name="local-and-world-transforms">Local and world transforms</a></h3>
<h3><a href="#自身转换和世界转换" name="自身转换和世界转换">自身转换和世界转换</a></h3>
<p>Calculating an object&#8217;s world transform is pretty straightforward&#8202;&mdash;&#8202;you just walk
its parent chain starting at the root all the way down to the object, combining
transforms as you go. In other words, the parrot&#8217;s world transform is:</p>
<p>计算对象的世界转换很直接——从它的父节点一直追踪到对象，将经过的所有转换绑在一起。
换言之，鹦鹉的世界转换如下：</p>
<p><span name="degenerate"></span>
<img src="images/dirty-flag-multiply.png" alt="The parrot's world position comes from multiplying the local positions for the ship, nest, pirate, and parrot." /></p>
<aside name="degenerate">
<p>In the degenerate case where the object has no parent, its local and world
transforms are equivalent.</p>
<p>在对象没有父对象的情况下，它的自身转换和世界转换是一样的。</p>
</aside>
<p>We need the world transform for every object in the world every frame, so even
though there are only a handful of matrix multiplications per model, it&#8217;s on the hot
code path where performance is critical. Keeping them up to date is tricky
because when a parent object moves, that affects the world transform of itself
and all of its children, recursively.</p>
<p>我们每帧需要为游戏世界的每个对象做世界转换，因此哪怕每个模型只有一部分矩阵乘法，当性能攸关时，它也在热点代码路径上。
保持它们更新是有技巧的，因为当父对象移动时，它影响自己的世界转换，并递归影响所有孩子节点。</p>
<p>The simplest approach is to calculate transforms on the fly while
rendering. Each frame, we recursively traverse the scene graph starting at the
top of the hierarchy. For each object, we calculate its world transform right
then and draw it.</p>
<p>最简单的方法是在渲染时计算转换。
每一帧，我们从最高层递归遍历整个场景图。
我们计算每个对象的世界转换然后绘制它。</p>
<p>But this is terribly wasteful of our precious CPU juice! Many objects in the
world are <em>not</em> moving every frame. Think of all of the static geometry that
makes up the level. Recalculating their world transforms each frame even though
they haven&#8217;t changed is a waste.</p>
<p>但这完全是在浪费CPU！
很多游戏世界的对象<em>不是</em>在每帧都移动。
想想那些构成关卡的静态几何图形。
在没有改变的情况下每帧计算它们的世界转换是一种浪费。</p>
<h3><a href="#cached-world-transforms" name="cached-world-transforms">Cached world transforms</a></h3>
<h3><a href="#缓存世界转换" name="缓存世界转换">缓存世界转换</a></h3>
<p>The obvious answer is to <em>cache</em> it. In each object, we store its local
transform and its derived world transform. When we render, we only use the
precalculated world transform. If the object never moves, the cached transform
is always up to date and everything&#8217;s happy.</p>
<p>明显的答案是<em>缓存</em>它。
在每个对象中，我们存储它的自身转换和世界转换。
当我们渲染时使用预计算的世界转换。
如果对象从未移动，缓存的转换永远跟得上变化，每个人都很开心。</p>
<p>When an object <em>does</em> move, the simple approach is to refresh its world
transform right then. But don&#8217;t forget the hierarchy! When a parent moves, we
have to recalculate its world transform <em>and all of its children&#8217;s,
recursively</em>.</p>
<p>当一个对象<em>确实</em>移动了，简单的解决方式是之后就更新世界转换。
但是不要忘记层次性！当父节点移动时，我们得计算它的世界转换并<em>递归计算它所有的子对象</em>。</p>
<p>Imagine some busy gameplay. In a single frame, the ship gets tossed on the
ocean, the crow&#8217;s nest rocks in the wind, the pirate leans to the edge, and the
parrot hops onto his head. We changed four local transforms. If we recalculate
world transforms eagerly whenever a local transform changes, what ends up
happening?</p>
<p>想象游戏中忙碌的时刻。
在一帧中，船在海上颠簸，瞭望塔在风中摇晃，海盗甩到了边缘，而鹦鹉撞上了他的脑袋。
我们改变了四个自身转换。如果每次自身转换都立即更新世界转换，会发生什么？</p>
<p><span name="stars"></span>
<img src="images/dirty-flag-update-bad.png" alt="Any time an object moves, the world coordinates are recalculated eagerly and redundantly." /></p>
<aside name="stars">
<p>You can see on the lines marked &#x2605; that we&#8217;re recalculating the parrot&#8217;s
world transform <em>four</em> times when we only need the result of the final one.</p>
<p>你可以看到在标为&#x2605;的线上，我们重复计算了鹦鹉世界转换四次，但我们只需要最终的结果。</p>
</aside>
<p>We only moved four objects, but we did <em>ten</em> world transform calculations.
That&#8217;s six pointless calculations that get thrown out before they are ever used
by the renderer. We calculated the parrot&#8217;s world transform <em>four</em> times, but it
is only rendered once.</p>
<p>我只移动四个对象，但我们做了<em>十次</em>世界转换计算。
那就有六次在被渲染器使用前浪费了。
我们计算了鹦鹉的世界转换<em>四</em>次，但它只需渲染一次。</p>
<p>The problem is that a world transform may depend on several local transforms.
Since we recalculate immediately each time <em>one</em> of the transforms changes, we end up
recalculating the same transform multiple times when more than one of the local
transforms it depends on changes in the same frame.</p>
<p>问题在于世界转换也许会依赖于多个自身转换。
由于我们<em>每次</em>变化就立即重新计算，当自身转换依赖的多个世界转换同一帧发生变化时，我们就对同一转换做了多次重新计算。</p>
<h3><a href="#deferred-recalculation" name="deferred-recalculation">Deferred recalculation</a></h3>
<h3><a href="#延期重计算" name="延期重计算">延期重计算</a></h3>
<p>We&#8217;ll solve this by <span name="decoupling">decoupling</span> changing local
transforms from updating the world transforms. This lets us change a bunch of
local transforms in a single batch and <em>then</em> recalculate the affected world
transform just once after all of those modifications are done, right before we
need it to render.</p>
<p>我们会通过<span name="decoupling">解耦</span>自身转换和世界转换的更新来解决这个问题。
这让我们先在一次批处理中改变自身转换，在这些改变完成<em>之后</em>，在我们需要渲染它之前，重新计算它们世界转换。</p>
<aside name="decoupling">
<p>It&#8217;s interesting how much of software architecture is intentionally
engineering a little slippage.</p>
<p>很有趣，不少软件架构是故意为工程增加灵活度。</p>
</aside>
<p>To do this, we add a <em>flag</em> to each object in the graph. &#8220;Flag&#8221; and &#8220;bit&#8221; are
synonymous in programming&#8202;&mdash;&#8202;they both mean a single micron of data that can be
in one of two states. We call those &#8220;true&#8221; and &#8220;false&#8221;, or sometimes &#8220;set&#8221; and
&#8220;cleared&#8221;. I&#8217;ll use all of these interchangeably.</p>
<p>为了做到这点，我们为图中的每个对象添加<em>标识位</em>。
“标识”和“位”在编程中密切相关——都代表一小块处在两种状态之一的数据。
我们称之为“真”和“假”，或者有时“设置”和“清除”。
我之后会交替使用它们。</p>
<p>When the local transform
changes, we set it. When we need the object&#8217;s world transform, we check the
flag. If it&#8217;s set, we calculate the world transform and then clear the flag. The
flag represents, &#8220;Is the world transform out of date?&#8221; For reasons that aren&#8217;t
entirely clear, the traditional name for this &#8220;out-of-date-ness&#8221; is &#8220;dirty&#8221;.
Hence: <em>a dirty flag</em>. &#8220;Dirty bit&#8221; is an equally
<span name="specific">common</span> name for this pattern, but I figured I&#8217;d
stick with the name that didn&#8217;t seem as prurient.</p>
<p>当自身转换改变了，我们设置它。
当我们需要对象的世界转换时，我们检查这位。
如果它被设置了，计算世界转换然后清除标识。
那个标识代表着，“世界转换过时了吗？”
由于它们没有清除，这种“过时的杂乱”被称为“脏”。
也就是<em>脏标识</em>。“脏位”也是这模式<span name="specific">通常</span>使用的名字，但是我决定使用不那么下流的称呼。</p>
<aside name="specific">
<p>Wikipedia&#8217;s editors don&#8217;t have my level of self-control and went with <a href="http://en.wikipedia.org/wiki/Dirty_bit">dirty
bit</a>.</p>
<p>维基百科的编辑者没有我这样的自我控制水平，使用了<a href="http://en.wikipedia.org/wiki/Dirty_bit">dirty bit</a>.</p>
</aside>
<p>If we apply this pattern and then move all of the objects in our previous
example, the game ends up doing:</p>
<p>如果我们应用这一章，然后移动之前例子中所有对象，那么游戏最终是这样的：</p>
<p><img src="images/dirty-flag-update-good.png" alt="By deferring until all moves are done, we only recalculate once." /></p>
<p>That&#8217;s the best you could hope to do&#8202;&mdash;&#8202;the world transform for each affected
object is calculated exactly once. With only a single bit of data, this pattern
does a few things for us:</p>
<p>这就是你能希望得到的最好结果了——每个受到影响的对象的世界转换只被计算一次。使用仅仅一位数据，这个模式为我们做了以下事情：</p>
<ul>
<li>
<p>It collapses modifications to multiple local transforms along an object&#8217;s
    parent chain into a single recalculation on the object.</p>
</li>
<li>
<p>它将对象的父节点链上的众多自身转换变化归并成对象上的一次计算。</p>
</li>
<li>
<p>It avoids recalculation on objects that didn&#8217;t move.</p>
</li>
<li>
<p>它避免了在没有移动的对象上重新计算。</p>
</li>
<li>
<p>And a minor bonus: if an object gets removed before it&#8217;s rendered, it
    doesn&#8217;t calculate its world transform at all.</p>
</li>
<li>
<p>还有一个小小的意外收获：如果对象在渲染前被删除了，不必再计算它的世界转换。</p>
</li>
</ul>
<h2><a href="#the-pattern" name="the-pattern">The Pattern</a></h2>
<h2><a href="#模式" name="模式">模式</a></h2>
<p>A set of <strong>primary data</strong> changes over time. A set of <strong>derived data</strong> is
determined from this using some <strong>expensive process</strong>. A <strong>&#8220;dirty&#8221; flag</strong> tracks
when the derived data is out of sync with the primary data. It is <strong>set when the
primary data changes</strong>. If the flag is set when the derived data is needed, then
<strong>it is reprocessed and the flag is cleared.</strong> Otherwise, the previous <strong>cached
derived data</strong> is used.</p>
<p>一组<em>原始数据</em>随着时间变化而改变。
使用<em>昂贵的过程</em>推定一组<em>导出数据</em>。
一个<em>“脏”标识</em>追踪导出数据是否与原始数据保持一致。
它在<em>原始数据改变时被设置。</em>
否则的话，使用之前<em>缓存的导出数据</em>。</p>
<h2><a href="#when-to-use-it" name="when-to-use-it">When to Use It</a></h2>
<h2><a href="#何时使用" name="何时使用">何时使用</a></h2>
<p>Compared to some other patterns in this book, this one solves a pretty specific
problem. Also, like most optimizations, you should only reach for it when you
have a performance problem big enough to justify the added code complexity.</p>
<p>与这本书中的其他模式相比，这个解决了一个非常特殊的问题。
同时，就像其他优化一样，只在有足够大的性能问题时，再使用这一章增加代码复杂度。</p>
<p>Dirty flags are applied to two kinds of work: <em>calculation</em> and
<em>synchronization</em>. In both cases, the process of going from the primary data to
the derived data is time-consuming or otherwise costly.</p>
<p>脏标识在两种任务上应用：“计算”和“同步”。
在两种情况下，从原始数据转换到导出数据消耗很多时间，或者有其他方面的消耗。</p>
<p>In our scene graph example, the process is slow because of the amount of math to
perform. When using this pattern for synchronization, on the other hand, it&#8217;s
more often that the derived data is <em>somewhere else</em>&#8202;&mdash;&#8202;either on disk or over
the network on another machine&#8202;&mdash;&#8202;and simply getting it from point A to point B
is what&#8217;s expensive.</p>
<p>在我们的场景图例子中，这个过程非常缓慢是因为需要执行很多数学运算。
应用这个章节在同步上，是另一个应用场景，
导出数据在<em>别的地方</em>——在磁盘上或者在网络另一头的终端机上——从点A到点B消耗很大。</p>
<p>There are a couple of other requirements too:</p>
<p>这里是一些其他应用场景：</p>
<ul>
<li>
<p><strong>The primary data has to change more often than the derived data is used.</strong>
    This pattern works by avoiding processing derived data when a subsequent
    primary data change would invalidate it before it gets used. If you find
    yourself always needing that derived data after every single modification
    to the primary data, this pattern can&#8217;t help.</p>
</li>
<li>
<p><em>原始数据的变化速度远高于导出数据的使用速度。</em>避免在导出数据使用前原始数据多次变化带来的不必要计算。如果你发现总在原始数据变化后使用导出数据，这个模式无法帮忙。</p>
</li>
<li>
<p><strong>It should be hard to update incrementally.</strong> Let&#8217;s say the
    pirate ship in our game can only carry so much booty. We need to
    know the total weight of everything in the hold. We
    <em>could</em> use this pattern and have a dirty flag for the total weight. Every
    time we add or remove some loot, we set the flag. When we need the
    total, we add up all of the booty and clear the flag.</p>
</li>
<li>
<p><em>增量更新应该是困难的。</em>假设海盗船只能携带特定数量的战利品。我们需要获取携带事物的总重量。我们<em>可以</em>使用这个模式，然后为总重量设脏标识。每次添加或者移除一些战利品，我们设置这个标识。当我们需要总量，将所有战利品重量加起来，然后清除标识。</p>
<p>But a simpler solution is to <em>keep a running total</em>. When we add or
remove an item, just add or remove its weight from the current total. If
we can &#8220;pay as we go&#8221; like this and keep the derived data updated, then
that&#8217;s often a better choice than using this pattern and calculating the
derived data from scratch when needed.</p>
<p>但是更简单的解决方法是<em>保存计算总量</em>。当我们添加或删除事物，直接从现在的总重量添加或者删除它的重量。如果我们可以<em>承担得起消耗</em>，保持导出数据更新，那么更好的选择是不用这个模式，每次需要时重新计算导出数据。</p>
</li>
</ul>
<p>This makes it sound like dirty flags are rarely appropriate, but you&#8217;ll
find a place here or there where they help. <span name="hacks">Searching</span>
your average game codebase for the word &#8220;dirty&#8221; will often turn up uses of this
pattern.</p>
<p>这听起来脏标识很少使用，但你会找到一两个部分它能帮得上忙。
直接在你的游戏代码库中<span name="hacks">搜索</span>“dirty”，通常会发现这个模式的使用。</p>
<aside name="hacks">
<p>From my research, it also turns up a lot of comments apologizing for &#8220;dirty&#8221;
hacks.</p>
<p>根据我的研究，也能找到很多对“dirty”黑魔法的抱怨注释。</p>
</aside>
<h2><a href="#keep-in-mind" name="keep-in-mind">Keep in Mind</a></h2>
<h2><a href="#记住" name="记住">记住</a></h2>
<p>Even after you&#8217;ve convinced yourself this pattern is a good fit, there are a few
wrinkles that can cause you some discomfort.</p>
<p>哪怕是在说服自己这个模式在这里很恰当之后，这里还有一些东西可能会让你不舒服。</p>
<h3><a href="#there-is-a-cost-to-deferring-for-too-long" name="there-is-a-cost-to-deferring-for-too-long">There is a cost to deferring for too long</a></h3>
<h3><a href="#延期太久是有代价的" name="延期太久是有代价的">延期太久是有代价的</a></h3>
<p>This pattern defers some slow work until the result is actually needed, but when
it is, it&#8217;s often needed <em>right now</em>. But the reason we&#8217;re using this pattern to
begin with is because calculating that result is slow!</p>
<p>这个模式将缓慢的工作延期到结果真正需要的时候，但是当它要的时候，通常是<em>现在就要</em>。
但是我们使用这个模式的原因是计算结果很慢！</p>
<p>This isn&#8217;t a problem in our example because we can still calculate world
coordinates fast enough to fit within a frame, but you can imagine other cases
where the work you&#8217;re doing is a big chunk that takes noticeable time to chew
through. If the game doesn&#8217;t <em>start</em> chewing until right when the player expects
to see the result, that can cause an unpleasant visible <span
name="gc">pause</span>.</p>
<p>在例子中，这不是问题，因为我们还是可以在一帧之内计算世界坐标，但是可以想象其他情况下，工作需要可观时间来进行。
如果玩家想要结果时才<em>开始</em>计算，这会引起不愉快的可见<span name="gc">暂停</span>。</p>
<p>Another problem with deferring is that if something goes wrong, you may fail to
do the work at all. This can be particularly problematic when you&#8217;re using this
pattern to save some state to a more persistent form.</p>
<p>延期的另一个问题是，如果有东西出错了，你也许根本做不了事情。
想要将模式存储为固定模式也许会造成问题。</p>
<p>For example, text editors know if your document has &#8220;unsaved changes&#8221;. That
little bullet or star in your file&#8217;s title bar is literally the dirty flag
visualized. The primary data is the open document in memory, and the derived
data is the file on disk.</p>
<p>举个例子，文本编辑器知道文档有“没保存的改变”。
在文件标题栏的小点或者星号就是可见的脏标识。
原始数据是在内存中打开的文档，推导数据是在磁盘上的文件。</p>
<p><img src="images/dirty-flag-title-bar.png" alt="A window titlebar showing the little icon representing unsaved changes." /></p>
<p>Many programs don&#8217;t save to disk until either the document is closed or the
application is exited. That&#8217;s fine most of the time, but if you accidentally
kick the power cable out, there goes your masterpiece.</p>
<p>很多程序直到文档关闭或者应用退出才保存到磁盘上。
在大多数情况下这很好，但是如果一不小心踢到了插线板，你的主要工作也就随风而逝了。</p>
<p>Editors that auto-save a backup in the background are compensating specifically
for this shortcoming. The auto-save frequency is a point on the continuum
between not losing too much work when a crash occurs and not thrashing the file
system too much by saving all the time.</p>
<p>在后台自动保存备份的编辑器是这一失误的补偿。
自动保存的频率保持在崩溃时不丢失太多数据和不总是打扰文件系统保存文件之间。</p>
<aside name="gc">
<p>This mirrors the different garbage collection strategies in systems that
automatically manage memory. Reference counting frees memory the second it&#8217;s no
longer needed, but it burns CPU time updating ref counts eagerly every time
references are changed.</p>
<p>这反映了系统中自动内存管理的不同的垃圾回收策略。
引用计数在不需要内存时立即释放它，但每次引用改变时都会更新引用计数，那消耗了大量CPU时间。</p>
<p>Simple garbage collectors defer reclaiming memory until it&#8217;s really needed, but
the cost is the dreaded &#8220;GC pause&#8221; that can freeze your entire game until the
collector is done scouring the heap.</p>
<p>简单的垃圾回收器将回收内存拖延到需要内存时，但是代价是可怕的，“垃圾回收过程”会冻住整个游戏，直到回收器完成了对堆的处理。</p>
<p>In between the two are more complex systems like deferred ref-counting and
incremental GC that reclaim memory less eagerly than pure ref-counting but more
eagerly than stop-the-world collectors.</p>
<p>在两者之间是更复杂的系统，像推迟的引用计数和增量的垃圾回收，比起纯粹的引用计数回收要消极，但比冻住游戏回收的系统更积极。</p>
</aside>
<h3><a href="#you-have-to-make-sure-to-set-the-flag-*every*-time-the-state-changes" name="you-have-to-make-sure-to-set-the-flag-*every*-time-the-state-changes">You have to make sure to set the flag <em>every</em> time the state changes</a></h3>
<h3><a href="#*每次*状态改变你都得保证设置标识。" name="*每次*状态改变你都得保证设置标识。"><em>每次</em>状态改变你都得保证设置标识。</a></h3>
<p>Since the derived data is calculated from the primary data, it&#8217;s essentially a
cache. Whenever you have cached data, the trickiest aspect of it is <span
name="cache"><em>cache invalidation</em></span>&#8202;&mdash;&#8202;correctly noting when the cache is
out of sync with its source data. In this pattern, that means setting the dirty
flag when <em>any</em> primary data changes.</p>
<p>由于推导数据是从原始数据推导而来的，它实际上是缓存。
无论何时缓存了数据，都是需要保证<span name="cache"><em>缓存一致性</em></span>——在缓存与原始数据不同步时通知之。
在这个模式上，这意味着在<em>任何</em>原始数据变化时设置脏标识。</p>
<aside name="cache">
<p>Phil Karlton famously said, &#8220;There are only two hard things in Computer Science:
cache invalidation and naming things.&#8221;</p>
<p>Phil Karlton有句名言：“计算机科学中只有两件难事：缓存一致性和命名。”</p>
</aside>
<p>Miss it in one place, and your program will incorrectly use stale derived data.
This leads to confused players and bugs that are very hard to track down. When you use
this pattern, you&#8217;ll have to take care that any code that modifies the primary
state also sets the dirty flag.</p>
<p>一处遗漏，你的程序就使用了不正确的推导数据。
这引起了玩家的困惑和非常难以追踪的漏洞。
当使用这个模式时，你也得注意，任何修改了原始数据的代码都得设置脏标识。</p>
<p>One way to mitigate this is by encapsulating modifications to the primary data
behind some interface. If anything that can change the state goes through a
single narrow API, you can set the dirty flag there and rest assured that it
won&#8217;t be missed.</p>
<p>一种解决它的方法是将原始数据的修改隐藏在接口之后。
任何想要改变状态的代码都要通过一个API，你可以在那里设置脏标识来保证不会遗漏。</p>
<h3><a href="#you-have-to-keep-the-previous-derived-data-in-memory" name="you-have-to-keep-the-previous-derived-data-in-memory">You have to keep the previous derived data in memory</a></h3>
<h3><a href="#得将之前的推导数据保存在内存中。" name="得将之前的推导数据保存在内存中。">得将之前的推导数据保存在内存中。</a></h3>
<p><span name="sync"></span></p>
<p><span name="sync"></span></p>
<p>When the derived data is needed and the dirty flag <em>isn&#8217;t</em> set, it uses the
previously calculated data. This is obvious, but that does imply that you have
to keep that derived data around in memory in case you end up needing it later.</p>
<p>当推导数据被请求而脏标识<em>没有</em>设置，它使用之前计算出的数据。
这很明显，但这需要在内存中保存推导数据，以防之后需要再次使用。</p>
<aside name="sync">
<p>This isn&#8217;t much of an issue when you&#8217;re using this pattern to synchronize the
primary state to some other place. In that case, the derived data isn&#8217;t usually
in memory at all.</p>
<p>如果你用这个模式将原始状态同步到其他地方，这不是问题。
那样的话，推导数据通常不再在内存里了。</p>
</aside>
<p>If you weren&#8217;t using this pattern, you could calculate the derived data on the
fly whenever you needed it, then discard it when you were done. That avoids the
expense of keeping it cached in memory at the cost of having to do that
calculation every time you need the result.</p>
<p>如果你没有使用这个模式，可在需要时计算推导数据，然后在完成后释放。
这避免了每次计算后都将其存储回内存的代价。</p>
<p>Like many optimizations, then, this pattern <span name="trade">trades</span>
memory for speed. In return for keeping the previously calculated data in
memory, you avoid having to recalculate it when it hasn&#8217;t changed. This
trade-off makes sense when the calculation is slow and memory is cheap. When
you&#8217;ve got more time than memory on your hands, it&#8217;s better to calculate it
as needed.</p>
<p>就像很多优化一样，这种模式以内存<span name="trade">换</span>速度。
通过在内存中保存之前计算的结果，避免了在它没有改变的情况下重新计算。
这种交易在内存便宜而计算昂贵时是划算的。
当你手头有更多空闲的时间而不是内存的时候，最好按需求重新计算之。</p>
<aside name="trade">
<p>Conversely, compression algorithms make the opposite trade-off: they optimize
<em>space</em> at the expense of the processing time needed to decompress.</p>
<p>相反，压缩算法做了反向的交易：
它们优化<em>空间</em>，代价是解压时额外的处理时间。</p>
</aside>
<h2><a href="#sample-code" name="sample-code">Sample Code</a></h2>
<h2><a href="#示例代码" name="示例代码">示例代码</a></h2>
<p>Let&#8217;s assume we&#8217;ve met the surprisingly long list of requirements and see how
the pattern looks in code. As I mentioned before, the actual math behind
transform matrices is beyond the humble aims of this book, so I&#8217;ll just
encapsulate that in a class whose implementation you can presume exists
somewhere out in the &aelig;ther:</p>
<p>假设我们满足了出奇长的需求列表，看看在代码中模式是如何应用的。
就像我之前提到的那样，矩阵变换背后的数学超出了本书的范围，因此我将其封装在类中，假设在其他某处已经实现了：</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Transform</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">static</span> <span class="n">Transform</span> <span class="n">origin</span><span class="p">();</span>

  <span class="n">Transform</span> <span class="nf">combine</span><span class="p">(</span><span class="n">Transform</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>


<p>The only operation we need here is <code>combine()</code> so that we can get an object&#8217;s
world transform by combining all of the local transforms along its parent chain.
It also has a method to get an &#8220;origin&#8221; transform&#8202;&mdash;&#8202;basically an identity
matrix that means no translation, rotation, or scaling at all.</p>
<p>这里我们唯一需要的操作就是<code>combine()</code>，
这样可以将父节点链上所有的自身转换组合起来获得对象的世界转换。
同样有办法来获得“原点”转换——通常是一个单位矩阵，没有平移，旋转，或者拉伸。</p>
<p>Next, we&#8217;ll sketch out the class for an object in the scene graph. This is the
bare minimum we need <em>before</em> applying this pattern:</p>
<p>下面，我们勾勒出场景图中的对象类。这是在应用模式<em>之前</em>，需要的最低限度的东西。</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">GraphNode</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">GraphNode</span><span class="p">(</span><span class="n">Mesh</span><span class="o">*</span> <span class="n">mesh</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">mesh_</span><span class="p">(</span><span class="n">mesh</span><span class="p">),</span>
    <span class="n">local_</span><span class="p">(</span><span class="n">Transform</span><span class="o">::</span><span class="n">origin</span><span class="p">())</span>
  <span class="p">{}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="n">Transform</span> <span class="n">local_</span><span class="p">;</span>
  <span class="n">Mesh</span><span class="o">*</span> <span class="n">mesh_</span><span class="p">;</span>

  <span class="n">GraphNode</span><span class="o">*</span> <span class="n">children_</span><span class="p">[</span><span class="n">MAX_CHILDREN</span><span class="p">];</span>
  <span class="kt">int</span> <span class="n">numChildren_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>Each node has a local transform which describes where it is relative to its
parent. It has a mesh which is the actual graphic for the object. (We&#8217;ll allow
<code>mesh_</code> to be <code>NULL</code> too to handle non-visual nodes that are used just to group
their children.) Finally, each node has a possibly empty collection of child
nodes.</p>
<p>每个节点都有原始转换描述了它和父节点之间的关系。
它有对象的真实网格。（将<code>mesh_</code>置为<code>NULL</code>来处理子节点的不可见节点。）
最终每个节点都有可能为空的子节点集合。</p>
<p>With this, a &#8220;scene graph&#8221; is really only a single root <code>GraphNode</code> whose
children (and grandchildren, etc.) are all of the objects in the world:</p>
<p>通过这样，“场景图”只是简单的<code>GraphNode</code>，它是所有的子节点（以及孙子节点）的根。</p>
<div class="codehilite"><pre><span></span><span class="n">GraphNode</span><span class="o">*</span> <span class="n">graph_</span> <span class="o">=</span> <span class="k">new</span> <span class="n">GraphNode</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
<span class="c1">// Add children to root graph node...</span>
</pre></div>


<p>In order to render a scene graph, all we need to do is traverse that tree of
nodes, starting at the root, and call the following function for each node&#8217;s mesh
with the right world transform:</p>
<p>为了渲染场景图，我们需要的就是从根开始遍历节点树，然后使用正确的世界变换为每个节点的网格调用函数：</p>
<div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="nf">renderMesh</span><span class="p">(</span><span class="n">Mesh</span><span class="o">*</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">Transform</span> <span class="n">transform</span><span class="p">);</span>
</pre></div>


<p>We won&#8217;t implement this here, but if we did, it would do whatever magic the
renderer needs to draw that mesh at the given location in the world. If we can
call that correctly and efficiently on every node in the scene graph, we&#8217;re
happy.</p>
<p>我们不会直接在这里实现，但是如果我们这么做了，那么它就会做渲染需要的事，将网格绘制在世界上给定的位置。
如果对场景图中的每个节点都正确有效地调用，这就愉快地完成了。</p>
<h3><a href="#an-unoptimized-traversal" name="an-unoptimized-traversal">An unoptimized traversal</a></h3>
<h3><a href="#一个没有优化的遍历" name="一个没有优化的遍历">一个没有优化的遍历</a></h3>
<p>To get our hands dirty, let&#8217;s throw together a basic traversal for rendering the
scene graph that calculates the world positions on the fly. It won&#8217;t be optimal,
but it will be simple. We&#8217;ll add a new method to <code>GraphNode</code>:</p>
<p>为了把手弄脏，我们做一个简单的遍历，在渲染需要时去计算所有的位置。
这没有优化，但它很简单。我们添加一个新方法给<code>GraphNode</code>：</p>
<div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="n">GraphNode</span><span class="o">::</span><span class="n">render</span><span class="p">(</span><span class="n">Transform</span> <span class="n">parentWorld</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">Transform</span> <span class="n">world</span> <span class="o">=</span> <span class="n">local_</span><span class="p">.</span><span class="n">combine</span><span class="p">(</span><span class="n">parentWorld</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">mesh_</span><span class="p">)</span> <span class="n">renderMesh</span><span class="p">(</span><span class="n">mesh_</span><span class="p">,</span> <span class="n">world</span><span class="p">);</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numChildren_</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">children_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">render</span><span class="p">(</span><span class="n">world</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>We pass the world transform of the node&#8217;s parent into this using <code>parentWorld</code>.
With that, all that&#8217;s left to get the correct world transform of <em>this</em> node is
to combine that with its own local transform. We don&#8217;t have to walk <em>up</em> the
parent chain to calculate world transforms because we calculate as we go while
walking <em>down</em> the chain.</p>
<p>使用<code>parentWorld</code>将父节点的世界转换传入节点。
这样，需要获得<em>这个</em>节点的世界转换只需要将其和节点本身转换相结合。
不需要<em>向上</em>遍历父节点去计算世界转换，因为我们可以在<em>向下</em>遍历时计算。</p>
<p>We calculate the node&#8217;s world transform and store it in <code>world</code>, then we render
the mesh, if we have one. Finally, we recurse into the child nodes, passing in
<em>this</em> node&#8217;s world transform. All in all, it&#8217;s a tight, simple recursive
method.</p>
<p>我们计算了节点的世界转换，将其存储到<code>world</code>，如果有网格，渲染它。
最后我们遍历进入子节点，传入<em>这个</em>节点的世界转换。
无论如何，这是一个紧密的，简单的遍历方法。</p>
<p>To draw an entire scene graph, we kick off the process at the root node:</p>
<p>为了绘制整个场景图，我们从根节点开始整个过程。</p>
<div class="codehilite"><pre><span></span><span class="n">graph_</span><span class="o">-&gt;</span><span class="n">render</span><span class="p">(</span><span class="n">Transform</span><span class="o">::</span><span class="n">origin</span><span class="p">());</span>
</pre></div>


<h3><a href="#let's-get-dirty" name="let's-get-dirty">Let&#8217;s get dirty</a></h3>
<h3><a href="#让我们变脏" name="让我们变脏">让我们变脏</a></h3>
<p>So this code does the right thing&#8202;&mdash;&#8202;it renders all the meshes in the right place
&#8212; but it doesn&#8217;t do it efficiently. It&#8217;s calling <code>local_.combine(parentWorld)</code>
on every node in the graph, every frame. Let&#8217;s see how this pattern fixes that.
First, we need to add two fields to <code>GraphNode</code>:</p>
<p>所以代码做了正确的事情——它在正确的地方渲染正确的网格——但是它没有有效地完成。
它在途中的每个节点上每帧调用<code>local_.combine(parentWorld)</code>。
让我们看看这个模式是如何修复这一点的。首先，我们给<code>GraphNode</code>添加两个字段。</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">GraphNode</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">GraphNode</span><span class="p">(</span><span class="n">Mesh</span><span class="o">*</span> <span class="n">mesh</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">mesh_</span><span class="p">(</span><span class="n">mesh</span><span class="p">),</span>
    <span class="n">local_</span><span class="p">(</span><span class="n">Transform</span><span class="o">::</span><span class="n">origin</span><span class="p">()),</span>
    <span class="n">dirty_</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span>
  <span class="p">{}</span>

  <span class="c1">// Other methods...</span>

<span class="k">private</span><span class="o">:</span>
  <span class="n">Transform</span> <span class="n">world_</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">dirty_</span><span class="p">;</span>
  <span class="c1">// Other fields...</span>
<span class="p">};</span>
</pre></div>


<p>The <code>world_</code> field caches the previously calculated world transform, and
<code>dirty_</code>, of course, is the dirty flag. Note that the flag starts out <code>true</code>.
When we create a new node, we haven&#8217;t calculated its world transform yet. At
birth, it&#8217;s already out of sync with the local transform.</p>
<p><code>world_</code>字段缓存了前一个计算出来的世界转换，和<code>dirty_</code>字段，当然，脏标识。
注意标识初始为<code>true</code>。当我们创建新节点时，我们还没有计算它的世界转换。
初始时，它与自身转换不是同步的。</p>
<p>The only reason we need this pattern is because objects can <em>move</em>, so let&#8217;s add
support for that:</p>
<p>我们需要这个模式的唯一原因是对象可以<em>移动</em>，因此让我们添加对这点的支持：</p>
<div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="n">GraphNode</span><span class="o">::</span><span class="n">setTransform</span><span class="p">(</span><span class="n">Transform</span> <span class="n">local</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">local_</span> <span class="o">=</span> <span class="n">local</span><span class="p">;</span>
  <span class="n">dirty_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>The important part here is that it sets the dirty flag too. Are we forgetting
anything? Right&#8202;&mdash;&#8202;the child nodes!</p>
<p>这里重要的部分是设置脏标识。我们忘了什么事吗？是的——子节点！</p>
<p>When a parent node moves, all of its children&#8217;s world coordinates are
invalidated too. But here, we aren&#8217;t setting their dirty flags. We <em>could</em> do
that, but that&#8217;s recursive and slow. Instead, we&#8217;ll do something clever when we
go to render. Let&#8217;s see:</p>
<p>当父节点移动时，它所有子节点的世界坐标也改变了。
但是这里，我们还没有设置它们的脏标识。
我们<em>可以</em>那样做，但是要递归而且缓慢。我们可以在渲染时做点更聪明的事。让我们看看：</p>
<p><span name="branch"></span></p>
<p><span name="branch"></span></p>
<div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="n">GraphNode</span><span class="o">::</span><span class="n">render</span><span class="p">(</span><span class="n">Transform</span> <span class="n">parentWorld</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">dirty</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">dirty</span> <span class="o">|=</span> <span class="n">dirty_</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">dirty</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">world_</span> <span class="o">=</span> <span class="n">local_</span><span class="p">.</span><span class="n">combine</span><span class="p">(</span><span class="n">parentWorld</span><span class="p">);</span>
    <span class="n">dirty_</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">mesh_</span><span class="p">)</span> <span class="n">renderMesh</span><span class="p">(</span><span class="n">mesh_</span><span class="p">,</span> <span class="n">world_</span><span class="p">);</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numChildren_</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">children_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">render</span><span class="p">(</span><span class="n">world_</span><span class="p">,</span> <span class="n">dirty</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<aside name="branch">
<p>There&#8217;s a subtle assumption here that the <code>if</code> check is faster than a matrix
multiply. Intuitively, you would think it is; surely testing a single bit is
faster than a bunch of floating point arithmetic.</p>
<p>这里有一个微妙的假设：<code>if</code>检查比矩阵乘法快。直观上，你会这么想，检测一位当然比一堆浮点计算要快。</p>
<p>However, modern CPUs are fantastically complex. They rely heavily on
<em>pipelining</em>&#8202;&mdash;&#8202;queueing up a series of sequential instructions. A branch like
our <code>if</code> here can cause a <em>branch misprediction</em> and force the CPU to lose cycles
refilling the pipeline.</p>
<p>但是，现代CPU超级复杂。它们严重依赖于<em>流水线</em>——入队的一系列连续指令。
像我们这里的<code>if</code>造成的分支会引发<em>分支预测失败</em>，强迫CPU消耗周期在填满流水线上。</p>
<p>The <a href="data-locality.html" class="pattern">Data Locality</a> chapter has
more about how modern CPUs try to go faster and how you can avoid tripping them
up like this.</p>
<p><a href="data-locality.html" class="pattern">数据局部性</a>一章有更多现代CPU是如何试图变快的，以及如何避免这样颠簸它们。</p>
</aside>
<p>This is similar to the original na&iuml;ve implementation. The key changes are that
we check to see if the node is dirty before calculating the world transform and
we store the result in a field instead of a local variable. When the node is
clean, we skip <code>combine()</code> completely and use the old-but-still-correct <code>world_</code>
value.</p>
<p>这与原先的原始实现很相似。
关键改变是我们在计算世界转换之前去检查节点是不是脏的，然后将结果存在字段中而不是本地变量中。
如果节点是干净的，我们完全跳过了<code>combine()</code>使用了老的但是正确的<code>world_</code>值。</p>
<p>The <span name="clever">clever</span> bit is that <code>dirty</code> parameter. That will
be <code>true</code> if any node above this node in the parent chain was dirty. In much the
same way that <code>parentWorld</code> updates the world transform incrementally as we
traverse down the hierarchy, <code>dirty</code> tracks the dirtiness of the parent chain.</p>
<p>这个<span name="clever">聪明</span>的位是<code>dirty</code>参数。
如果父节点链上有任何节点是脏的，那么就是<code>true</code>。
当我们顺着层次遍历下来，<code>parentWorld</code>用同样的方式更新它的世界转换，<code>dirty</code>追踪父节点链的是否有脏。</p>
<p>This lets us avoid having to recursively mark each child&#8217;s <code>dirty_</code> flag
in <code>setTransform()</code>. Instead, we pass the parent&#8217;s dirty flag down to its
children when we render and look at that too to see if we need to recalculate
the world transform.</p>
<p>这让我们避免递归地调用<code>setTransform()</code>标注每个子节点的<code>dirty_</code>标识。
相反，我们将父节点的脏标识传递给子节点，然后看看是否需要重新计算它的世界转换。</p>
<p>The end result here is exactly what we want: changing a node&#8217;s local transform
is just a couple of assignments, and rendering the world calculates the exact
minimum number of world transforms that have changed since the last frame.</p>
<p>这里结果正是我们需要的：改变节点的自身转换只是一些声明，渲染世界时只计算从上一帧开始所需的最小数量的世界转换。</p>
<aside name="clever">
<p>Note that this clever trick only works because <code>render()</code> is the <em>only</em> thing in
<code>GraphNode</code> that needs an up-to-date world transform. If other things accessed
it, we&#8217;d have to do something different.</p>
<p>注意这个技巧能有用是因为<code>render()</code>是<code>GraphNode</code>中<em>唯一</em>需要最新世界转换的。
如果其他东西也要获取，我们就得做点不同的事。</p>
</aside>
<h2><a href="#design-decisions" name="design-decisions">Design Decisions</a></h2>
<h2><a href="#设计决策" name="设计决策">设计决策</a></h2>
<p>This pattern is fairly specific, so there are only a couple of knobs to twiddle:</p>
<p>这种模式非常具体，所以只有几个旋钮来摆弄：</p>
<h3><a href="#when-is-the-dirty-flag-cleaned" name="when-is-the-dirty-flag-cleaned">When is the dirty flag cleaned?</a></h3>
<h3><a href="#什么时候清空脏标识？" name="什么时候清空脏标识？">什么时候清空脏标识？</a></h3>
<ul>
<li>
<p><strong>When the result is needed:</strong></p>
</li>
<li>
<p><em>当结果被请求时？</em></p>
<ul>
<li>
<p><em>It avoids doing calculation entirely if the result is never used.</em> For
    primary data that changes much more frequently than the derived data is
    accessed, this can be a big win.</p>
</li>
<li>
<p><em>如果不需要结果，可以完全避免计算。</em>如果原始数据变化的速度比推导数据获取的速度快得多，这可以是很大的胜利。</p>
</li>
<li>
<p><em>If the calculation is time-consuming, it can cause a noticeable pause.</em>
    Postponing the work until the player is expecting to see the result can
    affect their gameplay experience. It&#8217;s often fast enough that this
    isn&#8217;t a problem, but if it is, you&#8217;ll have to do the work earlier.</p>
</li>
<li>
<p><em>如果计算消耗大量时间，这会造成可察觉的暂停。</em>将工作推迟到玩家想要结果的时候会严重影响游戏体验。这部分工作一般足够快，不会构成问题，但是如果构成问题，你就需要早一些做这些工作。</p>
</li>
</ul>
</li>
<li>
<p><strong>At well-defined checkpoints:</strong></p>
</li>
<li>
<p><em>在好好定义的检查点处：</em></p>
<p>Sometimes, there is a point in time or in the progression of the game where it&#8217;s
natural to do the deferred processing. For example,
we may want to save the game only when the pirate sails into port. Or the
sync point may not be part of the game mechanics. We may just want to hide the
work behind a loading screen or a cut scene.</p>
<p>有时候，某个时间点或在游戏过程中很自然的需要推迟处理。例如，只有海盗船驶入港口才会去保存游戏。如果同步点不是游戏的机制，我们将这些工作隐藏在加载画面或者过场动画之后。</p>
<ul>
<li>
<p><em>Doing the work doesn&#8217;t impact the user experience.</em> Unlike the previous
  option, you can often give something to
    distract the player while the game is busy processing.</p>
</li>
<li>
<p><em>做这种工作不会影响到玩家体验。</em>不像前一个选项，游戏在紧张运行时，你总能转移玩家的注意力。</p>
</li>
<li>
<p><em>You lose control over when the work happens.</em> This is sort of the
    opposite of the earlier point. You have micro-scale control over when you
    process, and can make sure the game handles it gracefully.</p>
</li>
<li>
<p><em>会丧失何时工作的控制权。</em>这和前一个选项相反。你在进行时能微观控制，确保有效优雅地处理它。</p>
<p>What you <em>can&#8217;t</em> do is ensure the player actually makes it to the
checkpoint or meets whatever criteria you&#8217;ve defined. If they get lost
or the game gets in a weird state, you can end up deferring
longer than you expect.</p>
<p>你<em>不能</em>做的是保证玩家真的到了检查点或者满足了定义的条件。如果他们在游戏中迷失了，或者游戏进入了奇怪的状态，你最终会将工作推迟晚的超乎预料。</p>
</li>
</ul>
</li>
<li>
<p><strong>In the background:</strong></p>
</li>
<li>
<p><em>在后台处理：</em></p>
<p>Usually, you start a fixed <span name="hysteresis">timer</span>
on the first modification and then process all of the changes that happen
between then and when the timer fires.</p>
<p>通常情况下，你为每个更改启动固定间隔的<span name="hysteresis">计时器</span>，然后在计时器到时间后处理间隔中的所有变化。</p>
<aside name="hysteresis">

<p>The term in human-computer interaction for an intentional delay between
when a program receives user input and when it responds is <a href="http://en.wikipedia.org/wiki/Hysteresis"><em>hysteresis</em></a>.</p>
<p>在人机交互界，描述程序接受用户的输入和回应之间的故意延迟的术语是<a href="http://en.wikipedia.org/wiki/Hysteresis"><em>hysteresis</em></a>.</p>
</aside>

<ul>
<li>
<p><em>You can tune how often the work is performed.</em> By adjusting the timer
    interval, you can ensure it happens as frequently (or infrequently) as
    you want.</p>
</li>
<li>
<p><em>可以控制工作进行的频率。</em>通过调节计时器，可以保证它发生的像预期一样频繁（或者不频繁）。</p>
</li>
<li>
<p><em>You can do more redundant work.</em> If the primary state only changes a
    tiny amount during the timer&#8217;s run, you can end up processing a large
    chunk of mostly unchanged data.</p>
</li>
<li>
<p><em>更多冗余工作。</em>如果原始状态在计时器运行之间只改变了很少的部分，最终处理的大部分都是没有改变的数据。</p>
</li>
<li>
<p><em>You need support for doing work asynchronously.</em>
    Processing the data &#8220;in the background&#8221; implies that the player can
    keep doing whatever it is that they&#8217;re doing at the same time. That
    means you&#8217;ll likely need threading or some other kind of concurrency
    support so that the game can work on the data while it&#8217;s still
    being played.</p>
</li>
<li>
<p><em>需要同步支持工作。</em>
    在“后台”处理数据意味着玩家可以同时继续做正在做的事情。这就意味着你将会需要线程或者其他并行支持，这样游戏在处理数据的同时仍然可以继续游玩。</p>
<p>Since the player is likely interacting with
the same primary state that you&#8217;re processing, you&#8217;ll need to think
about making that safe for concurrent modification too.</p>
<p>由于玩家很可能与处理中的状态交互，你也需要考虑保持同步修改的安全。</p>
</li>
</ul>
</li>
</ul>
<h3><a href="#how-fine-grained-is-your-dirty-tracking" name="how-fine-grained-is-your-dirty-tracking">How fine-grained is your dirty tracking?</a></h3>
<h3><a href="#脏追踪做的有多细粒度？" name="脏追踪做的有多细粒度？">脏追踪做的有多细粒度？</a></h3>
<p>Imagine our pirate game lets players build and customize their pirate ship.
Ships are automatically saved online so the player can resume where they left
off. We&#8217;re using dirty flags to determine which decks of the ship have been
fitted and need to be sent to the server. Each chunk of data we send to the
server contains some modified ship data and a bit of metadata describing where
on the ship this modification occurred.</p>
<p>假设我们的海盗游戏允许玩家建造并个性化自己的船。
船在线自动保存，这样玩家可以从离开的地方继续。
我们使用脏标识记录船的哪块甲板被修改了，从而需要发送到服务器。
每一块发送给服务器的数据都包括了修改的船数据和一些描述船的哪里被修改的元数据。</p>
<ul>
<li>
<p><strong>If it&#8217;s more fine-grained:</strong></p>
</li>
<li>
<p><em>如果粒度更细：</em></p>
<p>Say you slap a dirty flag on each tiny plank of each deck.</p>
<p>假设你为甲板上的每个小木板都拍上一个脏标识。</p>
<ul>
<li>
<p><em>You only process data that actually changed.</em> You&#8217;ll send exactly the
    facets of the ship that were modified to the server.</p>
</li>
<li>
<p><em>你只需处理真正改变的数据。</em>你只处理船上修改了的数据到服务器。</p>
</li>
</ul>
</li>
<li>
<p><strong>If it&#8217;s more coarse-grained:</strong></p>
</li>
<li>
<p><em>如果粒度更粗：</em></p>
<p>Alternatively, we could associate a dirty bit with each deck.
Changing anything on it marks the entire deck <span name="swab">dirty</span>.</p>
<p>或者，我们可以每层甲板关联一个脏标识。改变它上面的任何东西都会让整个甲板<span name="swab">变脏</span>。</p>
<aside name="swab">

<p>I could make some terrible joke about it needing to be swabbed here, but
I&#8217;ll refrain.</p>
<p>我可以说些这里需要清洗的糟糕笑话，但我克制住了。</p>
</aside>

<ul>
<li>
<p><em>You end up processing unchanged data.</em> Add a single barrel to a deck
    and you&#8217;ll have to send the whole thing to the server.</p>
</li>
<li>
<p><em>最终需要处理没有变化的数据。</em>在甲板上添加一个桶，就要将全部的东西发送到服务器。</p>
</li>
<li>
<p><em>Less memory is used for storing dirty flags.</em> Add ten barrels to a deck
    and you only need a single bit to track them all.</p>
</li>
<li>
<p><em>更少的内存被用在存储脏标识上。</em>为甲板上添加十个桶只需要一位来追踪。</p>
</li>
<li>
<p><em>Less time is spent on fixed overhead.</em> When processing some changed data,
   there&#8217;s often a bit of fixed work you have to do on top of handling the
   data itself. In the example here, that&#8217;s the metadata required to
   identify where on the ship the changed data is. The bigger your
   processing chunks, the fewer of them there are, which means the less
   overhead you have.</p>
</li>
<li>
<p><em>较少的时间花在固定开销上。</em>当处理某些改变的数据时，通常处理数据之前有些固定的工作。在这个例子中，是需要确认船上改变的数据在哪里的元数据。处理的块越大，那么要处理的数量就越少，这就意味着有更小的开销。</p>
</li>
</ul>
</li>
</ul>
<h2><a href="#see-also" name="see-also">See Also</a></h2>
<h2><a href="#参见" name="参见">参见</a></h2>
<ul>
<li>
<p>This pattern is common outside of games in browser-side web frameworks like
    <a href="http://angularjs.org/">Angular</a>. They use dirty flags to track which data
    has been changed in the browser and needs to be pushed up to the server.</p>
</li>
<li>
<p>这个模式在游戏之外的像<a href="http://angularjs.org/">Angular</a>的浏览器方向框架，是很常见的。它们使用脏标识来追踪哪个数据在浏览器中被改变了，需要将数据推向服务器。</p>
</li>
<li>
<p>Physics engines track which objects are in motion and which are resting.
    Since a resting body won&#8217;t move until an impulse is applied to it, they
    don&#8217;t need processing until they get touched. This &#8220;is moving&#8221; bit is a
    dirty flag to note which objects have had forces applied and need to have
    their physics resolved.</p>
</li>
<li>
<p>物理引擎追踪哪些对象在运动中哪些在休息。由于休息的骨骼直到有力施加在上面才会移动，它们被碰到才会需要处理。这种“正在移动”的位是一个脏标识，标注哪个对象上面有力施加，需要物理解析。</p>
</li>
</ul>
<nav>
  <span class="prev">&larr; <a href="data-locality.html">上一章</a></span>
  <span class="next"><a href="object-pool.html">下一章</a> &rarr;</span>
  <span class="toc">&equiv; <a href="/Game-Programming-Patterns-CN/">首页</a></span>
</nav>
</div>
</div>
<footer>&copy; 2009-2015 Robert Nystrom</footer>
</body>
</html>
