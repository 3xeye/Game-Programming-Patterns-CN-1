<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN" lang="zh-CN">
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />

<title>序 &middot; 游戏设计模式</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />

<script src="jquery-1.10.1.min.js"></script>
<script src="script.js"></script>
</head>
<body id="top">
<div class="page sidebar">
<div class="content">
<nav class="top">
  <span class="prev">&larr; <a href="acknowledgements.html">上一章</a></span>
  <span class="next"><a href="architecture-performance-and-games.html">下一章</a> &rarr;</span>
  <span class="toc">&equiv; <a href="/Game-Programming-Patterns-CN/">首页</a></span>
</nav>
<h1>序</h1>
<h1 class="book"><a href="/Game-Programming-Patterns-CN/">游戏设计模式</a></h1>
<p>在五年级，我和我的朋友被准许进入一间有非常破旧的TRS-80s的房间。
为了激励我们，一位老师为我们准备了一些简单的BASIC程序去摆治。</p>
<p>驱动电脑的磁带已经坏掉了，所以任何时候我们想要去允许写代码，我们就必须得小心地从头输入。
这样我们更喜欢那些只有几行长的程序：</p>
<p><span name="radical"></span></p>
<div class="codehilite"><pre><span></span>10 PRINT &quot;BOBBY IS RADICAL!!!&quot;
20 GOTO 10
</pre></div>


<aside name="radical">
<p>也许如果计算机输出足够多次，它就会魔法般成真。</p>
</aside>
<p>哪怕这样，过程也充满了危险。我们不知道如何编程，所以一个小小的语法错误对我们也是不可逾越的。
如果程序没有工作，通常如此，我们得从头开始。</p>
<p>书的最后几页是一个真正的怪物：一个占据了几页代码的程序。
在我们鼓起勇气尝试它之前花费了一些时间，但它实在诱人——列表的标题是“地道与巨魔”。
我们不知道它会做什么，但听起来像是一个游戏，还有什么比你自己编一个电脑游戏更酷的吗？</p>
<p>我们从来没能让它运行起来，过了一年，我们离开了那件教室。
（在很久以后我真正学会了一点BASIC，我意识到那只是个桌面游戏角色生成器而非游戏。）
但是结局已经注定——从那开始，我想要成为游戏程序员。</p>
<p>当我还是青少年，我家有了一台Macintosh，能运行QuickBASIC，之后能运行THINK C。
我花费了几乎整个<span name="snakes">暑假</span>编游戏。
自学缓慢而痛苦。
我需要让东西跑起来——也许是地图或者解密游戏——但随着程序代码增长，这越来越难。</p>
<aside name="snakes">
<p>暑假的很多时候我也在路易斯安那州的沼泽里逮蛇和乌龟。
如果外面不是那么酷热，很有可能这是一本爬虫书而不是编程书了。</p>
</aside>
<p>早先，挑战是让所有东西运行起来。然后，是搞明白怎样写出我脑袋装不下的代码。
不是只阅读“如何用C++编程”，我开始尝试找那些如何<em>组织</em>程序的书。</p>
<p>在早先的几年里，一位<span name="friend">朋友</span>给我一本书：《设计模式：可复用面向对象软件的基础》。
终于！在从青年时期就在找的书找到了。
我一口气从头读到尾。我仍然在我的程序中挣扎，但看到别人也在挣扎并尝试找到解决方法是一种解脱。
我意识到我终于有些除双手外的<em>工具</em>了。</p>
<aside name="friend">
<p>那是我们首次见面，在五分钟介绍后，我坐在他的沙发上，在接下来几个小时，忽视他并阅读。
我想自那以后我的社交技能有所提高。</p>
</aside>
<p>在2001年，我获得了梦想的工作：EA的软件工程师。
我等不及要看看真实的游戏是如何的，那些专业人士是如何将他们组织到一切的。
像实况足球这样的巨大游戏使用了什么样的架构？不同的系统是如何交互的？他们是如何使用单一的代码库在多个平台上运行的？</p>
<p>打开源代码是恭敬而震惊的体验。那有图形，AI，动画，视觉效果的杰出代码。
我们有直到如何榨干CPU的最后一个循环并好好使用的专家。
那些我<em>想都没想过</em>的事情，这些人已经完成了。</p>
<p>但是这些杰出代码依赖的<em>架构</em>就是之后考虑的了。
他们太注重<em>特性</em>而忽视了架构。耦合充斥在模块间。
新的功能通常被塞到任何能塞进去的地方。
在我梦想破灭的眼中，这和其他程序员没什么不同，
如果他们阅读过《设计模式》，最多也就用用 <a class="pattern" href="singleton.html">单例</a>。</p>
<p>当然，没那么糟。我设想游戏程序员坐在白板包围的象牙塔里，为架构冷静地讨论上几周。
现实是我看到的代码是由努力应对紧张截止期限的人完成的。
他们尽他们所能，而且，就像我逐渐意识到的那样，他们通常完成的很好。
我花在游戏代码上的时间越多，我就越能发现藏在表面下的杰作。</p>
<p>不幸的是，“藏”通常是个很好的描述。
通常有宝石埋在代码中，但人们直接从它们上面越过。
我看到合作伙伴挣扎着重复发明解决方案，而事实上他们需要的就埋在他们所用的代码库中。</p>
<p>这个问题是这本书要解决的。
我挖出了我在游戏中找到最好的模式，然后在这里展示它们，这样我们可以花时间在发明新事物上，而非“重新”发明它们。</p>
<h2><a href="#这有什么" name="这有什么">这有什么</a></h2>
<p>市面上已经有很多游戏编程书籍了。为什么要再写一本呢？</p>
<p>我看到的很多编程书籍可以归为这两类：</p>
<ul>
<li>
<p><strong>特定领域的书籍。</strong>这些狭窄领域的书籍给你关于游戏开发某一特定层面的深入研究。他们会教授你3D图形，实时渲染，物理模拟，人工智能，或者音频播放。那些事很多程序员究其一生研究的特定领域。</p>
</li>
<li>
<p><strong>完整引擎的书籍。</strong>相反，还有试图探索引擎的所有不同部分的书。他们倾向于构建一个特定种类游戏的引擎，通常是第三人称射击游戏。</p>
</li>
</ul>
<p>我喜欢这些书，但我认为他们之间有些缝隙。特定领域的书籍很少告诉你这些代码如何与游戏的其他部分打交道。
你也许是物理或者渲染上的专家，但是你直到这么将它们两者绑在一起吗？</p>
<p>第二类书包含里这一点，但是我通常发现完整引擎的书籍通常过于整体，而且过于特定类型了。
特别随着手游和碎片时间游戏兴起，我们处于众多游戏类型创建的时刻。
我们不只是复制Quake了。如果<em>你的</em>游戏与它不同，那些带你遍历单一引擎的书就不那么有用了。</p>
<p>相反，我在这里做的更<span name="carte"><em>&agrave; la carte</em> </span>。
每一章都是一个独立的，你可以应用到代码上的意图。
这样，你可以以<em>你</em>认为对游戏最好的方式混合并组合它们。</p>
<aside name="carte">
<p>另一个这种<em>&agrave; la carte</em>风格广泛应用的例子是<a href="http://www.satori.org/game-programming-gems/"><em>Game Programming Gems</em></a>系列。</p>
</aside>
<h2><a href="#它和设计模式有什么关联" name="它和设计模式有什么关联">它和设计模式有什么关联</a></h2>
<p>任何有<span name="alexander">“模式”</span>在它名字中的编程书都与Erich Gamma，Richard Helm，Ralph Johnson，和John Vlissides（通常被称为GoF）合著的经典《设计模式：可复用面向对象软件要素》相关。</p>
<aside name="alexander">
<p>《设计模式》本书受到之前的一本书的启发。创建一种关于描述问题的开放式解法的模式的语言来自 <a href="http://en.wikipedia.org/wiki/A_Pattern_Language"><em>A Pattern Language</em></a>，作者是Christopher Alexander (还有Sarah Ishikawa和Murray Silverstein).</p>
<p>他们的书关于架构（就像建筑和墙那样的<em>真实</em>架构），但他们希望其他人使用相同的结构去描述其他领域的解法。
《设计模式》是GoF在软件业做出的努力。</p>
</aside>
<p>称这本书为“游戏编程模式”，我不是暗示GoF的书<span name="nongames">不适用</span>于游戏。
相反：本书<a href="design-patterns-revisited.html">重返设计模式</a>一节包含了《设计模式》中的很多模式，但是增加了对如何应用于游戏编程的强调。</p>
<p>同样的，我认为本书也适用于非游戏软件。
我可以同样称本书为“更多设计模式”，但是我认为游戏制作是更契合的例子。
你真的像要另一本书介绍员工记录和银行账户吗？</p>
<p>虽然这里介绍的模式在其他软件上也很有用，但我认为它们对于处理游戏中常见的工程挑战更加合适：</p>
<ul>
<li>
<p>时间和顺序通常是游戏架构的核心部分。事物必须以正确的顺序发生在正确的时间。</p>
</li>
<li>
<p>开发周期高度压缩，很多程序员需要能快速构建和迭代一系列不同的行为，而不会踩到别人的脚趾，或者在代码库中留下一堆痕迹。</p>
</li>
<li>
<p>在所有的行为都定义后，它开始交互。怪物咬英雄，药物混合，炸弹炸飞敌人或者友军。实现这些交互不能把代码库搞成一团乱麻。</p>
</li>
<li>
<p>最终，性能在游戏中很关键。游戏开发者在一场谁能榨干平台性能的竞赛中。能节约CPU循环的技巧是A级百万销量游戏和掉帧差评游戏间的区分之处。</p>
</li>
</ul>
<h2><a href="#如何阅读这本书" name="如何阅读这本书">如何阅读这本书</a></h2>
<p>《游戏设计模式》本分为三大块。
第一部分介绍书的框架，是你现在阅读的这章和<a href="architecture-performance-and-games.html">下一章</a>。</p>
<p>第二部分，<a href="design-patterns-revisited.html">重放设计模式</a>，复习了GoF书籍里的很多模式。
在每一章中，我给你了我对这个模式的看法，以及我认为它和游戏编程有什么关系。</p>
<p>最后一部分是这本书最肥美的部分。
它展示了十三种我发现有用的模式。他们被分为四类：
<a href="sequencing-patterns.html">序列模式</a>, <a href="behavioral-patterns.html">行为模式</a>, <a href="decoupling-patterns.html">解耦模式</a>,和<a href="optimization-patterns.html">优化模式</a>。</p>
<p>每种模式都使用固定的格式，这样你可以将这本书视为引用，快速找到你需要的：</p>
<ul>
<li>
<p><strong>意图</strong>一节提供这个模式想要解决什么问题的简短介绍。将它放在首位，这样可以很快翻一遍然后找到你现在需要的模式。</p>
</li>
<li>
<p><strong>动机</strong>一节描述了我们需要应用的问题。不像具体的算法，模式通常不针对某一个问题。不用示例教模式就像不用面团教烘烤。这一届提供了面团而下一节会烘烤它。</p>
</li>
<li>
<p><strong>模式</strong>一节将模式从例子中剥离出来。如果你想要一段教科书式的对模式的简短介绍，那就是这部分了。如果你已经熟悉了这一种模式，想要确保你没有忘掉什么，它也是很好的提示。</p>
</li>
<li>
<p>到目前为止，模式只是用一两个例子解释。但是你如何知道模式对<em>你的</em>问题有没有用呢？<strong>何时使用</strong>一节提供了这个模式在何时有用何时最好回避。<strong>记住</strong>一节指出了使用模式的结果和危险。</p>
</li>
<li>
<p>如果，像我，你需要具体的例子来<em>理解</em>某物，那么<strong>示例代码</strong>如你所愿。它通过模式的一步步具体实现来展示模式是如何工作的。</p>
</li>
<li>
<p>模式与算法不同的是它们是开放的。每一次你使用模式，你会以不同的方式实现。下一节<strong>设计决策</strong>，探索了这个空间，给了你不同的选项去考虑如何应用模式。</p>
</li>
<li>
<p>作为结尾，这里有<strong>参见</strong>一节展示了这一模式与其他模式的关联，以及那些使用它的真实代码。</p>
</li>
</ul>
<h2><a href="#关于示例代码" name="关于示例代码">关于示例代码</a></h2>
<p>这本书的代码是用C++写就的，但是并不意味着这些模式只在C++中有用，或者C++对他们比其他语言更适用。
几乎每种语言都能好好工作，虽然该有的模式假设你的语言有对象和类。</p>
<p>我选择C++有几个原因。首先，这是在发布游戏中最流行的语言。
这是业界的<em>通用语</em>。
通常，C++基于的C语法也是Java，C#，JavaScript和其他很多语言的基础。
哪怕你不懂C++，你也只需一点点努力就能理解这里的示例代码。</p>
<p>这本书的目标<em>不是</em>教会你C++。
示例代码尽可能的简单，不真正代表好的C++风格或规范。
阅读示例代码展示的是意图，而不是代码。</p>
<p>特别的，代码不是用“现代”——C++11或者更新的——标准。
没有使用标准库，很少使用模板。
这是“坏的”C++代码，但我希望尽可能简明易懂，对那些从C，Objective-C，Java和其他语言的人更容易理解。</p>
<p>为了避免花费时间在你已经看过或者是与模式无关的代码上，代码有时在例子中省略了。
如果是那样，一串省略号会在示例代码中表明隐藏了一些代码。</p>
<p>想想那些做了些工作然后返回值的代码。
展示的模式只关心返回的值，而不是完成了什么工作。那样的话，示例代码长的像这样：</p>
<div class="codehilite"><pre><span></span><span class="kt">bool</span> <span class="nf">update</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// Do work...</span>
  <span class="k">return</span> <span class="n">isDone</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>


<h2><a href="#接下来呢" name="接下来呢">接下来呢</a></h2>
<p>模式在软件开发过程中不断的改变和扩展。
这本书继续了GoF记录分享所见模式的旅程，而这旅程也会在笔墨已干后继续。</p>
<p>你是这段旅程的核心部分。在你改良（或者否决）了这本书中的模式，你回馈给软件开发团体。
如果你有任何建议，更正，或者有关这里的任何反馈，请联系我！</p>
<nav>
  <span class="prev">&larr; <a href="acknowledgements.html">上一章</a></span>
  <span class="next"><a href="architecture-performance-and-games.html">下一章</a> &rarr;</span>
  <span class="toc">&equiv; <a href="/Game-Programming-Patterns-CN/">首页</a></span>
</nav>
</div>
</div>
<footer>&copy; 2009-2015 Robert Nystrom</footer>
</body>
</html>
