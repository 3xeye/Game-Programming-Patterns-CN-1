<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />

<title>Component &middot; Decoupling Patterns &middot; Game Programming Patterns</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />
<link href="http://fonts.googleapis.com/css?family=Merriweather:400,400italic,700,700italic|Source+Code+Pro|Source+Sans+Pro:200,300,400,600,400italic,600italic|Rock+Salt" rel="stylesheet" type="text/css">
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-1', 'gameprogrammingpatterns.com');
  ga('send', 'pageview');
</script>
<script src="jquery-1.10.1.min.js"></script>
<script src="script.js"></script>
</head>
<body id="top">
<div class="page sidebar">
<div class="content">
<nav class="top">
  <span class="prev">&larr; <a href="decoupling-patterns.html">Previous Chapter</a></span>
  <span class="next"><a href="event-queue.html">Next Chapter</a> &rarr;</span>
  <span class="toc">&equiv; <a href="/">The Book</a></span>
</nav>
<h1>Component</h1>
<h1 class="book"><a href="/">Game Programming Patterns</a><span class="section"><a href="decoupling-patterns.html">Decoupling Patterns</a></span></h1>
<p>组件模式
解耦模式</p>
<h2><a href="#intent" name="intent">Intent</a></h2>
<h2><a href="#意图" name="意图">意图</a></h2>
<p><em>Allow a single entity to span multiple domains without coupling the domains to
each other.</em></p>
<p><em>允许单一的实体跨越多个域，无需将这些域耦合彼此。</em></p>
<h2><a href="#motivation" name="motivation">Motivation</a></h2>
<h2><a href="#动机" name="动机">动机</a></h2>
<p>Let&#8217;s say we&#8217;re building a platformer. The Italian plumber demographic is
covered, so ours will star a Danish <span name="baker">baker</span>, Bj&oslash;rn. It
stands to reason that we&#8217;ll have a class representing our friendly pastry chef,
and it will contain everything he does in the game.</p>
<p>比方说，我们正在构建平台跳跃游戏。意大利水管工已经有人做了，因此我们将出动丹麦的面包师，Bjorn。照理说，会有有一个类来表示友好的糕点厨师，将包含他在比赛中做的一切。</p>
<aside name="baker">
<p>Brilliant game ideas like this are why I&#8217;m a programmer and not a designer.</p>
</aside>
<p>Since the player controls him, that means reading controller input and
translating that input into motion. And, of course, he needs to interact with the level,
so some physics and collision go in there. Once that&#8217;s done, he&#8217;s got to show
up on screen, so toss in animation and rendering. He&#8217;ll probably play some
sounds too.</p>
<p>由于玩家控制他，这意味着读取控制器的输入然后转化为运动。而且，当然，他需要与关卡相互作用，
所以要引入物理和碰撞。一旦这样做了，他必须在屏幕上出现，所以要引入动画和渲染。他可能还会播放一些声音。</p>
<p>Hold on a minute; this is getting out of control. Software Architecture 101
tells us that different domains in a program should be kept isolated from each
other. If we&#8217;re making a word processor, the code that handles printing
shouldn&#8217;t be affected by the code that loads and saves documents. A game doesn&#8217;t
have the same domains as a business app, but the rule still applies.</p>
<p>等一下;这在失控。软件体系结构101课程告诉我们，在一个程序不同域应保持分离。如果我们做一个文字处理器，处理打印的代码不应该受加载和保存文件的代码影响。一个游戏和企业应用程序没有相同的域，但该规则仍然适用。</p>
<p>As much as possible, we don&#8217;t want AI, physics, rendering, sound and other
domains to know about each other, but now we&#8217;ve got all of that crammed into one
class. We&#8217;ve seen where this road leads to: a 5,000-line dumping ground source
file so big that only the bravest ninja coders on your team even dare to go in
there.</p>
<p>我们希望AI，物理，渲染，声音和其他域尽可能不相互了解，但现在我们将所有这一切挤在一个类中。我们已经看到了这条路通往何处：5000行的巨大代码文件，哪怕是你们团队中最勇敢的程序员也不敢进去。</p>
<p>This is great job security for the few who can tame it, but it&#8217;s hell for the rest of
us. A class that big means even the most seemingly trivial changes can have
far-reaching implications. Soon, the class collects <em>bugs</em> faster than it
collects <em>features</em>.</p>
<p>对于能驯服他的少数人这是伟大的工作，但对我们中的其他人是地狱。这么大的类意味着，即使是看似微不足道的变化可以有深远的影响。很快，为类添加<em>错误</em>速度明显快于添加<em>功能</em>。</p>
<h3><a href="#the-gordian-knot" name="the-gordian-knot">The Gordian knot</a></h3>
<h3><a href="#快刀斩乱麻" name="快刀斩乱麻">快刀斩乱麻</a></h3>
<p>Even worse than the simple scale problem is the <span name="coupling">coupling
</span> one. All of the different systems in our game have been tied into a
giant knotted ball of code like:</p>
<p>比起单纯的规模问题，更糟糕的是耦合。在我们的游戏中所有不同的系统被绑成了一个巨大的代码球。</p>
<div class="codehilite"><pre><span class="k">if</span> <span class="p">(</span><span class="n">collidingWithFloor</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">getRenderState</span><span class="p">()</span> <span class="o">!=</span> <span class="n">INVISIBLE</span><span class="p">))</span>
<span class="p">{</span>
  <span class="n">playSound</span><span class="p">(</span><span class="n">HIT_FLOOR</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>Any programmer trying to make a change in code like that will need to know
something about physics, graphics, and sound just to make sure they don&#8217;t break
anything.</p>
<p>任何试图改变代码的程序员，都需要知道一些关于物理，图形和声音的知识，而这只是为了确保不破坏什么。</p>
<aside name="coupling">
<p>While coupling like this sucks in <em>any</em> game, it&#8217;s even worse on modern games
that use concurrency. On multi-core hardware, it&#8217;s vital that code is running on
multiple threads simultaneously. One common way to split a game across threads
is along domain boundaries&#8202;&mdash;&#8202;run AI on one core, sound on another, rendering on a
third, etc.</p>
<p>Once you do that, it&#8217;s critical that those domains stay decoupled in order to
avoid deadlocks or other fiendish concurrency bugs. Having a single class with
an <code>UpdateSounds()</code> method that must be called from one thread and a
<code>RenderGraphics()</code> method that must be called from another is begging for
those kinds of bugs to happen.</p>
</aside>
<p>These two problems compound each other; the class touches so many domains that
every programmer will have to work on it, but it&#8217;s so huge that doing so is a
nightmare. If it gets bad enough, coders will start putting hacks in other parts
of the codebase just to stay out of the hairball that this <code>Bjorn</code> class has
become.</p>
<p>这两个问题彼此混合;这个类涉及如此多的域，每个程序员都得接触它，但它是如此巨大，这就变成了一场噩梦。。如果它变得够糟糕，程序员会黑入代码库的其他部分，仅仅为了躲开这个像毛球一样的<code>Bjorn</code>类。</p>
<h3><a href="#cutting-the-knot" name="cutting-the-knot">Cutting the knot</a></h3>
<h3><a href="#抽剑断结" name="抽剑断结">抽剑断结</a></h3>
<p>We can solve this like Alexander the Great&#8202;&mdash;&#8202;with a sword. We&#8217;ll take our
monolithic <code>Bjorn</code> class and slice it into separate parts along domain
boundaries. For example, we&#8217;ll take all of the code for handling user input and
move it into a separate <code>InputComponent</code> class. <code>Bjorn</code> will then own an
instance of this component. We&#8217;ll repeat this process for each of the domains that
<code>Bjorn</code> touches.</p>
<p>我们可以像亚历山大大帝一样解决这个问题——用剑。将<code>Bjorn</code>类切片成沿域独立的部分。例如，我们抽出所有处理用户输入的代码，将其移动到一个单独的<code>InputComponent</code>类。 <code>Bjorn</code>拥有这个部件的一个实例。我们将对于每个<code>Bjorn</code>接触域重复这一过程。</p>
<p>When we&#8217;re done, we&#8217;ll have moved almost everything out of <code>Bjorn</code>. All that
remains is a thin shell that binds the components together. We&#8217;ve solved our
huge class problem by simply dividing it up into multiple smaller classes, but
we&#8217;ve accomplished more than just that.</p>
<p>当我们完成后，我们将几乎所有<code>Bjorn</code>的东西都抽走了。剩下的是一个薄壳包着所有的组件。通过将类划分为多个小类，我们已经解决了这个问题。但我们完成了远远不止这些。</p>
<h3><a href="#loose-ends" name="loose-ends">Loose ends</a></h3>
<h3><a href="#宽松的结果" name="宽松的结果">宽松的结果</a></h3>
<p>Our component classes are now decoupled. Even though <code>Bjorn</code> has a
<code>PhysicsComponent</code> and a <code>GraphicsComponent</code>, the two don&#8217;t know about each
other. This means the person working on physics can modify their component
without needing to know anything about graphics and vice versa.</p>
<p>我们的组件类现在解耦了。尽管<code>Bjorn</code>有<code>PhysicsComponent</code>和<code>GraphicsComponent</code>，这两部分都不知道对方的存在。这意味着处理物理的人可以修改组件而不需要了解图形，反之亦然。</p>
<p>In practice, the components will need to have <em>some</em> interaction between
themselves. For example, the AI component may need to tell the physics component
where Bj&oslash;rn is trying to go. However, we can restrict this to the
components that <em>do</em> need to talk instead of just tossing them all in the same
playpen together.</p>
<p>在实践中，这些部件需要在他们之间有<em>一些</em>相互作用。例如，AI组件可能需要告诉物理组件
Bj&oslash;rn试图去哪里。然而，我们可以限制这种交互在<em>确实</em>需要交互的组件之间，而不是把他们围在同一个围栏里。</p>
<h3><a href="#tying-back-together" name="tying-back-together">Tying back together</a></h3>
<h3><a href="#绑到一起" name="绑到一起">绑到一起</a></h3>
<p>Another feature of this design is that the <span
name="inheritance">components</span> are now reusable packages. So far, we&#8217;ve
focused on our baker, but let&#8217;s consider a couple of other kinds of objects in
our game world. <em>Decorations</em> are things in the world the player sees but
doesn&#8217;t interact with: bushes, debris and other visual detail. <em>Props</em> are like
decorations but can be touched: boxes, boulders, and trees. <em>Zones</em> are the
opposite of decorations&#8202;&mdash;&#8202;invisible but interactive. They&#8217;re useful for things
like triggering a cutscene when Bj&oslash;rn enters an area.</p>
<p>这种设计的另一个特性是，所述组件现在是可复用的包。到目前为止，我们专注于面包师，但是让我们考虑几个游戏世界中其他类型的对象。<em>装饰</em>是玩家看到但不能交互的事物：灌木，杂物等视觉细。 <em>道具</em>像
<em>装饰</em>，但可以交互：箱，巨石，树木。 <em>区</em>与装饰相反——无形的，但互动。它们是很好的触发器，比如设计Bj&oslash;rn进入区域触发过场动画。</p>
<aside name="inheritance">
<p>When object-oriented programming first hit the scene, inheritance was the
shiniest tool in its toolbox. It was considered the ultimate code-reuse hammer,
and coders swung it often. Since then, we&#8217;ve learned the hard way that it&#8217;s a
heavy hammer indeed. Inheritance has its uses, but it&#8217;s often too cumbersome for
simple code reuse.</p>
<p>Instead, the growing trend in software design is to use composition instead of
inheritance when possible. Instead of sharing code between two classes by having
them <em>inherit</em> from the same class, we do so by having them both <em>own an
instance</em> of the same class.</p>
</aside>
<p>Now, consider how we&#8217;d set up an inheritance hierarchy for those classes if we
weren&#8217;t using components. A first pass might look like:</p>
<p>现在，考虑如果我们不用组件，我们将如何建立这些类的继承层次。第一遍可能是这样的：</p>
<p><img src="images/component-uml.png" alt="A class diagram. Zone has collision code and inherits from GameObject. Decoration also inherits from GameObject and has rendering code. Prop inherits from Zone but then has redundant rendering code." /></p>
<p>We have a base <code>GameObject</code> class that has common stuff like position and
orientation. <code>Zone</code> inherits from that and adds collision detection. Likewise,
<code>Decoration</code> inherits from <code>GameObject</code> and adds rendering. <code>Prop</code> inherits from
<code>Zone</code>, so it can reuse the collision code. However, <code>Prop</code> can&#8217;t <em>also</em> inherit
from <code>Decoration</code> to reuse the <em>rendering</em> code without running into the <span
name="diamond">Deadly Diamond</span>.</p>
<p>我们有基础的<code>GameObject</code>类，包含位置和方向之类的通用部分。<code>Zone</code>继承它，增加了碰撞检测。同样，
<code>Decoration</code>继承<code>GameObject</code>，并增加了渲染。 <code>Prop</code>继承<code>Zone</code>，因此它可以重用碰撞代码。然而，<code>Prop</code>不能<em>同时</em>继承<code>Decoration</code>来重用<em>渲染</em>，否则就会造成致命的菱形结构。</p>
<aside name="diamond">
<p>The &#8220;Deadly Diamond&#8221; occurs in class hierarchies with multiple inheritance where
there are two different paths to the same base class. The pain that causes is a
bit out of the scope of this book, but understand that they named it
&#8220;deadly&#8221; for a reason.</p>
</aside>
<p>We could flip things around so that <code>Prop</code> inherits from <code>Decoration</code>, but then
we end up having to duplicate the <em>collision</em> code. Either way, there&#8217;s no clean
way to reuse the collision and rendering code between the classes that need it
without resorting to multiple inheritance. The only other option is to push
everything up into <code>GameObject</code>, but then <code>Zone</code> is wasting memory on rendering
data it doesn&#8217;t need and <code>Decoration</code> is doing the same with physics.</p>
<p>我们可以反过来让<code>Prop</code>继承<code>Decoration</code>，但随后我们最终不得不重复<em>碰撞</em>码。无论哪种方式，没有干净方式重用碰撞和渲染代码而不诉诸多重继承。唯一的其他选择是
一切都继承<code>GameObject</code>，但随后<code>Zone</code>浪费内存在并不需要的渲染数据上，<code>Decoration</code>对物理效果有同样的浪费。</p>
<p>Now, let&#8217;s try it with components. Our <span name="menu">subclasses</span> disappear
completely. Instead, we have a single <code>GameObject</code> class and two component
classes: <code>PhysicsComponent</code> and <code>GraphicsComponent</code>. A decoration is simply a
<code>GameObject</code> with a <code>GraphicsComponent</code> but no <code>PhysicsComponent</code>. A zone is the
opposite, and a prop has both components. No code duplication, no multiple
inheritance, and only three classes instead of four.</p>
<p>现在，让我们尝试用组件。我们的子类彻底消失。相反，我们有一个<code>GameObject</code>类和双组分类：<code>PhysicsComponent</code>和<code>GraphicsComponent</code>。装饰是一个简单的<code>GameObject</code>包含<code>GraphicsComponent</code>但没有<code>PhysicsComponent</code>。一个区恰恰相反，一个道具包含两种组件。没有代码重复，没有多重继承，只有三个类，而不是四个。</p>
<aside name="menu">
<p>A restaurant menu is a good analogy. If each entity is a monolithic class, it&#8217;s
like you can only order combos. We need to have a separate class for each
possible <em>combination</em> of features. To satisfy every customer, we would need
dozens of combos.</p>
<p>Components are &agrave; la carte dining&#8202;&mdash;&#8202;each customer can select just the
dishes they want, and the menu is a list of the dishes they can choose
from.</p>
</aside>
<p>Components are basically plug-and-play for objects. They let us build complex
entities with rich behavior by plugging different reusable component
objects into sockets on the entity. Think software Voltron.</p>
<p>对对象而言，组件是即插即用的。通过将不同的可重用部件插入对象，他们让我们构建复杂具有丰富的行为实体。就像软件类的战神金刚。</p>
<h2><a href="#the-pattern" name="the-pattern">The Pattern</a></h2>
<h2><a href="#模式" name="模式">模式</a></h2>
<p>A <strong>single entity spans multiple domains</strong>. To keep the domains isolated, the
code for each is placed in its own <strong><span name="component">component</span>
class</strong>. The entity is reduced to a simple <strong>container of components</strong>.</p>
<p><strong>跨越多个域的单一的实体</strong>。为了保持域分离，将每部分的代码放入<em>各自的组件类</em>中。实体被简化为一个<em>组件的容器</em>。</p>
<aside name="component">
<p>&#8220;Component&#8221;, like &#8220;Object&#8221;, is one of those words that means everything and
nothing in programming. Because of that, it&#8217;s been used to describe a few
concepts. In business software, there&#8217;s a &#8220;Component&#8221; design pattern that
describes decoupled services that communicate over the web.</p>
<p>I tried to find a different name for this unrelated pattern found in games, but
&#8220;Component&#8221; seems to be the most common term for it. Since design patterns are
about documenting existing practices, I don&#8217;t have the luxury of coining a new
term. So, following in the footsteps of XNA, Delta3D, and others, &#8220;Component&#8221; it
is.</p>
</aside>
<h2><a href="#when-to-use-it" name="when-to-use-it">When to Use It</a></h2>
<h2><a href="#何时使用" name="何时使用">何时使用</a></h2>
<p>Components are most commonly found within the core class that defines the
entities in a game, but they may be useful in other places as well. This pattern can
be put to good use when any of these are true:</p>
<p>组件通常在定义游戏实体的核心部分被使用，但它们在其他地方也会很有用。这个模式在如下情况中可以使用：</p>
<ul>
<li>
<p>You have a class that touches multiple domains which you want to keep
    decoupled from each other.</p>
</li>
<li>
<p>有一个涉及了多个域的类，而你想保持这些类互相隔离。</p>
</li>
<li>
<p>A class is getting massive and hard to work with.</p>
</li>
<li>
<p>一个类正在变大而且越来越难以使用。</p>
</li>
<li>
<p>You want to be able to define a variety of objects that share different
    capabilities, but using inheritance doesn&#8217;t let you pick the parts you
    want to reuse precisely enough.</p>
</li>
<li>
<p>你想要能定义一系列分享不同能力的类，但是使用接口不足以让你得到足够的重用部分。</p>
</li>
</ul>
<h2><a href="#keep-in-mind" name="keep-in-mind">Keep in Mind</a></h2>
<h2><a href="#记住" name="记住">记住</a></h2>
<p>The Component pattern adds a good bit of complexity over simply making a class and
putting code in it. Each conceptual &#8220;object&#8221; becomes a cluster of objects that
must be instantiated, initialized, and correctly wired together. Communication
between the different components becomes more challenging, and controlling how
they occupy memory is more complex.</p>
<p>组件模式比简单的向类中添加代码增加了一点点复杂性。每一个每一个概念上的“对象”要组成真正的对象需要被实例化，被初始化，然后正确的连接到一起。在不同组件中沟通会有些困难，而控制他们如何使用内存就更加复杂。</p>
<p>For a large codebase, this complexity may be worth it for the decoupling and
code reuse it enables, but take care to ensure you aren&#8217;t over-engineering a
&#8220;solution&#8221; to a non-existent problem before applying this pattern.</p>
<p>对于大的代码库，为了解耦和重用而付出这样的复杂度是值得的。但是在使用这种模式之前，保证你没有为了一个不存在的问题而“过度设计”。</p>
<p>Another consequence of using components is that you often have to hop through a
level of indirection to get anything done. Given the container object, first you
have to get the component you want, <em>then</em> you can do what you need. In <span
name="perf">performance</span>-critical inner loops, this pointer following may
lead to poor performance.</p>
<p>组件的另一个后果是，你需要多一层跳转才能去做你要去做的事。拿到一个容器对象，先得获得相应的组件，<em>然后</em>你猜才能获得你想要的组件。在性能攸关的内部循环中，这种跳转也许会导致糟糕的性能。</p>
<aside name="perf">
<p>There&#8217;s a flip side to this coin. The Component pattern can often <em>improve</em>
performance and cache coherence. Components make it easier to use the <a
class="pattern" href="data-locality.html"> Data Locality</a> pattern to organize
your data in the order that the CPU wants it.</p>
</aside>
<h2><a href="#sample-code" name="sample-code">Sample Code</a></h2>
<h2><a href="#示例代码" name="示例代码">示例代码</a></h2>
<p>One of the biggest challenges for me in writing this book is figuring out how to
isolate each pattern. Many design patterns exist to contain code that itself
isn&#8217;t part of the pattern. In order to distill the pattern down to its essence,
I try to cut as much of that out as possible, but at some point it becomes a bit
like explaining how to organize a closet without showing any clothes.</p>
<p>我写这本书的一个最大挑战就是搞明白如何隔离各个模式。许多设计模式包含了并不属于这种模式的代码。为了将模式提取到它的本质表现，我尽可能的消减代码，但是有些时候这就像没有衣服还要说明如何整理衣柜。</p>
<p>The Component pattern is a particularly hard one. You can&#8217;t get a real feel for
it without seeing some code for each of the domains that it decouples, so I&#8217;ll
have to sketch in a bit more of Bj&oslash;rn&#8217;s code than I&#8217;d like. The pattern is
really only the component <em>classes</em> themselves, but the code in them should
help clarify what the classes are for. It&#8217;s fake code&#8202;&mdash;&#8202;it calls into other
classes that aren&#8217;t presented here&#8202;&mdash;&#8202;but it should give you an idea of what
we&#8217;re going for.</p>
<p>组件模式是特别难的一个。如果看不到它解耦的各个域的代码，你就不能获得正确的感觉，因此我会多写一些有关于Bj&oslash;rn的代码。这个模式事实上只关于将组件变为<em>类</em>，但类中的代码可以帮助表明这些类是做什么用的。这是伪代码——他调用了其他不存在的类——但这应该可以给你一个我们正在做什么的概念。</p>
<h3><a href="#a-monolithic-class" name="a-monolithic-class">A monolithic class</a></h3>
<h3><a href="#单块类" name="单块类">单块类</a></h3>
<p>To get a clearer picture of how this pattern is applied, we&#8217;ll start by showing
a monolithic <span name="cat"><code>Bjorn</code></span> class that does everything we need
but <em>doesn&#8217;t</em> use this pattern:</p>
<p>为了清晰的看到这个模式是如何应用的，我们需要先展示一个<code>Bjorn</code>类，它包含了所有我们需要但是在这个模式中<em>不需要</em>的事物的。</p>
<aside name="cat">
<p>I should point out that using the actual name of the character in the codebase
is usually a bad idea. The marketing department has an annoying habit of
demanding name changes days before you ship. &#8220;Focus tests show males between 11
and 15 respond negatively to &lsquo;Bj&oslash;rn&rsquo;. Use &lsquo;Sven&rsquo;
instead.&#8221;</p>
<p>This is why many software projects use internal-only codenames. Well, that and
because it&#8217;s more fun to tell people you&#8217;re working on &#8220;Big Electric Cat&#8221; than
just &#8220;the next version of Photoshop.&#8221;</p>
</aside>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">Bjorn</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Bjorn</span><span class="p">()</span>
  <span class="o">:</span> <span class="n">velocity_</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
    <span class="n">x_</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">y_</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
  <span class="p">{}</span>

  <span class="kt">void</span> <span class="n">update</span><span class="p">(</span><span class="n">World</span><span class="o">&amp;</span> <span class="n">world</span><span class="p">,</span> <span class="n">Graphics</span><span class="o">&amp;</span> <span class="n">graphics</span><span class="p">);</span>

<span class="k">private</span><span class="o">:</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">WALK_ACCELERATION</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">velocity_</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">x_</span><span class="p">,</span> <span class="n">y_</span><span class="p">;</span>

  <span class="n">Volume</span> <span class="n">volume_</span><span class="p">;</span>

  <span class="n">Sprite</span> <span class="n">spriteStand_</span><span class="p">;</span>
  <span class="n">Sprite</span> <span class="n">spriteWalkLeft_</span><span class="p">;</span>
  <span class="n">Sprite</span> <span class="n">spriteWalkRight_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p><code>Bjorn</code> has an <code>update()</code> method that gets called once per frame by the game:</p>
<p><code>Bjorn</code>有一个每帧调用的<code>update()</code>方法。</p>
<div class="codehilite"><pre><span class="kt">void</span> <span class="n">Bjorn</span><span class="o">::</span><span class="n">update</span><span class="p">(</span><span class="n">World</span><span class="o">&amp;</span> <span class="n">world</span><span class="p">,</span> <span class="n">Graphics</span><span class="o">&amp;</span> <span class="n">graphics</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Apply user input to hero&#39;s velocity.</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">Controller</span><span class="o">::</span><span class="n">getJoystickDirection</span><span class="p">())</span>
  <span class="p">{</span>
    <span class="k">case</span> <span class="nl">DIR_LEFT</span><span class="p">:</span>
      <span class="n">velocity_</span> <span class="o">-=</span> <span class="n">WALK_ACCELERATION</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>

    <span class="k">case</span> <span class="nl">DIR_RIGHT</span><span class="p">:</span>
      <span class="n">velocity_</span> <span class="o">+=</span> <span class="n">WALK_ACCELERATION</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Modify position by velocity.</span>
  <span class="n">x_</span> <span class="o">+=</span> <span class="n">velocity_</span><span class="p">;</span>
  <span class="n">world</span><span class="p">.</span><span class="n">resolveCollision</span><span class="p">(</span><span class="n">volume_</span><span class="p">,</span> <span class="n">x_</span><span class="p">,</span> <span class="n">y_</span><span class="p">,</span> <span class="n">velocity_</span><span class="p">);</span>

  <span class="c1">// Draw the appropriate sprite.</span>
  <span class="n">Sprite</span><span class="o">*</span> <span class="n">sprite</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">spriteStand_</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">velocity_</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">sprite</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">spriteWalkLeft_</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">velocity_</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">sprite</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">spriteWalkRight_</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">graphics</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="o">*</span><span class="n">sprite</span><span class="p">,</span> <span class="n">x_</span><span class="p">,</span> <span class="n">y_</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>It reads the joystick to determine how to accelerate the baker. Then it resolves
its new position with the physics engine. Finally, it draws Bj&oslash;rn onto the
screen.</p>
<p>它读取操纵杆以确定如何加速面包师。然后，它用物理引擎解析它的新位置。最后，将Bj&oslash;rn渲染至屏幕。</p>
<p>The sample implementation here is trivially simple. There&#8217;s no gravity,
animation, or any of the dozens of other details that make a character fun to
play. Even so, we can see that we&#8217;ve got a single function that several
different coders on our team will probably have to spend time in, and it&#8217;s
starting to get a bit messy. Imagine this scaled up to a thousand lines and you
can get an idea of how painful it can become.</p>
<p>这里的示例实现是平凡简单。没有重力，动画，或任何让人物有趣的其他细节，。即便如此，我们可以看到，已经有了一个不同的程序员将花费时间于其上的单一功能函数，而且它开始变得有点混乱。想象一下放大到一千行，你就知道这会有多难受了。</p>
<h3><a href="#splitting-out-a-domain" name="splitting-out-a-domain">Splitting out a domain</a></h3>
<h3><a href="#分离领域" name="分离领域">分离领域</a></h3>
<p>Starting with one domain, let&#8217;s pull a piece out of <code>Bjorn</code> and push it into a
separate component class. We&#8217;ll start with the first domain that gets processed:
input. The first thing <code>Bjorn</code> does is read in user input and adjust his
velocity based on it. Let&#8217;s move that logic out into a separate class:</p>
<p>从一个域开始，让我们从<code>Bjorn</code>去除一部分将它归入一个分离的组件类。我们从第一个开始执行的域开始：输入。<code>Bjorn</code>做的第一件事就是读取玩家的输入，然后基于此调整他的速度。让我们将这部分逻辑移入一个分离的类：</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">InputComponent</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="kt">void</span> <span class="n">update</span><span class="p">(</span><span class="n">Bjorn</span><span class="o">&amp;</span> <span class="n">bjorn</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">Controller</span><span class="o">::</span><span class="n">getJoystickDirection</span><span class="p">())</span>
    <span class="p">{</span>
      <span class="k">case</span> <span class="nl">DIR_LEFT</span><span class="p">:</span>
        <span class="n">bjorn</span><span class="p">.</span><span class="n">velocity</span> <span class="o">-=</span> <span class="n">WALK_ACCELERATION</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>

      <span class="k">case</span> <span class="nl">DIR_RIGHT</span><span class="p">:</span>
        <span class="n">bjorn</span><span class="p">.</span><span class="n">velocity</span> <span class="o">+=</span> <span class="n">WALK_ACCELERATION</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">WALK_ACCELERATION</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>Pretty simple. We&#8217;ve taken the first section of <code>Bjorn</code>&rsquo;s <code>update()</code>
method and put it into this class. The changes to <code>Bjorn</code> are also
straightforward:</p>
<p>很简答把吧。我们将<code>Bjorn</code>的<code>update()</code>取出，将其放入这个类。对<code>Bjorn</code>的改变也很直接：</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">Bjorn</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="kt">int</span> <span class="n">velocity</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>

  <span class="kt">void</span> <span class="nf">update</span><span class="p">(</span><span class="n">World</span><span class="o">&amp;</span> <span class="n">world</span><span class="p">,</span> <span class="n">Graphics</span><span class="o">&amp;</span> <span class="n">graphics</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">input_</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>

    <span class="c1">// Modify position by velocity.</span>
    <span class="n">x</span> <span class="o">+=</span> <span class="n">velocity</span><span class="p">;</span>
    <span class="n">world</span><span class="p">.</span><span class="n">resolveCollision</span><span class="p">(</span><span class="n">volume_</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">velocity</span><span class="p">);</span>

    <span class="c1">// Draw the appropriate sprite.</span>
    <span class="n">Sprite</span><span class="o">*</span> <span class="n">sprite</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">spriteStand_</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">velocity</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">sprite</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">spriteWalkLeft_</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">velocity</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">sprite</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">spriteWalkRight_</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">graphics</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="o">*</span><span class="n">sprite</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
  <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="n">InputComponent</span> <span class="n">input_</span><span class="p">;</span>

  <span class="n">Volume</span> <span class="n">volume_</span><span class="p">;</span>

  <span class="n">Sprite</span> <span class="n">spriteStand_</span><span class="p">;</span>
  <span class="n">Sprite</span> <span class="n">spriteWalkLeft_</span><span class="p">;</span>
  <span class="n">Sprite</span> <span class="n">spriteWalkRight_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p><code>Bjorn</code> now owns an <code>InputComponent</code> object. Where before he was handling user
input directly in the <code>update()</code> method, now he delegates to the component:</p>
<p><code>Bjorn</code>现在拥有了一个<code>InputComponent</code>对象。之前它在<code>update()</code>方法中直接处理用户输入，现在他用组件代替：</p>
<div class="codehilite"><pre><span class="n">input_</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
</pre></div>


<p>We&#8217;ve only started, but already we&#8217;ve gotten rid of some coupling&#8202;&mdash;&#8202;the main
<code>Bjorn</code> class no longer has any reference to <code>Controller</code>. This will come in
handy later.</p>
<p>我们刚刚开始，但我们已经摆脱了一些耦合——主要的<code>Bjorn</code>现在已经与<code>Controller</code>无关了。这会派上用场的。</p>
<h3><a href="#splitting-out-the-rest" name="splitting-out-the-rest">Splitting out the rest</a></h3>
<h3><a href="#将剩下的分割出来" name="将剩下的分割出来">将剩下的分割出来</a></h3>
<p>Now, let&#8217;s go ahead and do the same cut-and-paste job on the physics and graphics
code. Here&#8217;s our new <code>PhysicsComponent</code>:</p>
<p>现在让我们对物理和图像代码继续这种剪切粘贴的工作。这是我们新的 <code>PhysicsComponent</code>：</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">PhysicsComponent</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="kt">void</span> <span class="n">update</span><span class="p">(</span><span class="n">Bjorn</span><span class="o">&amp;</span> <span class="n">bjorn</span><span class="p">,</span> <span class="n">World</span><span class="o">&amp;</span> <span class="n">world</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">bjorn</span><span class="p">.</span><span class="n">x</span> <span class="o">+=</span> <span class="n">bjorn</span><span class="p">.</span><span class="n">velocity</span><span class="p">;</span>
    <span class="n">world</span><span class="p">.</span><span class="n">resolveCollision</span><span class="p">(</span><span class="n">volume_</span><span class="p">,</span>
        <span class="n">bjorn</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">bjorn</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">bjorn</span><span class="p">.</span><span class="n">velocity</span><span class="p">);</span>
  <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="n">Volume</span> <span class="n">volume_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>In addition to moving the physics <em>behavior</em> out of the main <code>Bjorn</code> class, you
can see we&#8217;ve also moved out the <em>data</em> too: The <code>Volume</code> object is now owned by
the component.</p>
<p>为了将物理<em>行为</em>移出<code>Bjorn</code>类，你可以看到我们也移出了<em>数据</em>：<code>Volume</code>对象已经是部件的一部分了。</p>
<p>Last but not least, here&#8217;s where the rendering code lives now:</p>
<p>最后，这是现在的渲染代码：</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">GraphicsComponent</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="kt">void</span> <span class="n">update</span><span class="p">(</span><span class="n">Bjorn</span><span class="o">&amp;</span> <span class="n">bjorn</span><span class="p">,</span> <span class="n">Graphics</span><span class="o">&amp;</span> <span class="n">graphics</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">Sprite</span><span class="o">*</span> <span class="n">sprite</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">spriteStand_</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">bjorn</span><span class="p">.</span><span class="n">velocity</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">sprite</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">spriteWalkLeft_</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bjorn</span><span class="p">.</span><span class="n">velocity</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">sprite</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">spriteWalkRight_</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">graphics</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="o">*</span><span class="n">sprite</span><span class="p">,</span> <span class="n">bjorn</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">bjorn</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
  <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="n">Sprite</span> <span class="n">spriteStand_</span><span class="p">;</span>
  <span class="n">Sprite</span> <span class="n">spriteWalkLeft_</span><span class="p">;</span>
  <span class="n">Sprite</span> <span class="n">spriteWalkRight_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>We&#8217;ve yanked almost everything out, so what&#8217;s left of our humble pastry chef?
Not much:</p>
<p>我们几乎将所有的东西都移出来了，所以我们谦虚的面包师还剩下什么？没什么了：</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">Bjorn</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="kt">int</span> <span class="n">velocity</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>

  <span class="kt">void</span> <span class="nf">update</span><span class="p">(</span><span class="n">World</span><span class="o">&amp;</span> <span class="n">world</span><span class="p">,</span> <span class="n">Graphics</span><span class="o">&amp;</span> <span class="n">graphics</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">input_</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
    <span class="n">physics_</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">world</span><span class="p">);</span>
    <span class="n">graphics_</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">graphics</span><span class="p">);</span>
  <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="n">InputComponent</span> <span class="n">input_</span><span class="p">;</span>
  <span class="n">PhysicsComponent</span> <span class="n">physics_</span><span class="p">;</span>
  <span class="n">GraphicsComponent</span> <span class="n">graphics_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>The <code>Bjorn</code> class now basically does two things: it holds the set of components
that actually define it, and it holds the state that is shared across multiple
domains. Position and velocity are still in the core <code>Bjorn</code> class for two
reasons. First, they are &#8220;pan-domain&#8221; state&#8202;&mdash;&#8202;almost every component will make
use of them, so it isn&#8217;t clear which component <em>should</em> own them if we did want
to push them down.</p>
<p><code>Bjorn</code>类现在基本呢上就做两件事：他拥有定义它的组件，以及在不同域之间要分享的数据。有两个原因导致位置和速度仍然在<code>Bjorn</code>的核心类中：首先，他们是“泛领域”状态——几乎每个组件都需要使用他们，所以我们想要提取出来的时候，哪个组件<em>应该</em>拥有他们并不明确。</p>
<p>Secondly, and more importantly, it gives us an easy way for the components to
communicate without being coupled to each other. Let&#8217;s see if we can put that to
use.</p>
<p>第二，而且更重要的是，他给了我们无需让组件耦合就能沟通的简易方法。让我们看看我们能不能使用这一点。</p>
<h3><a href="#robo-bj&oslash;rn" name="robo-bj&oslash;rn">Robo-Bj&oslash;rn</a></h3>
<h3><a href="#robo-bj&oslash;rn" name="robo-bj&oslash;rn">Robo-Bj&oslash;rn</a></h3>
<p>So far, we&#8217;ve pushed our behavior out to separate component classes, but we
haven&#8217;t <em>abstracted</em> the behavior out. <code>Bjorn</code> still knows the exact concrete
classes where his behavior is defined. Let&#8217;s change that.</p>
<p>到目前为止，我们将我们的行为归入了不同的组件类，但哦我们还没有将行为<em>抽象</em>出来。<code>Bjorn</code>还是知道每个类的具体定义的行为。让我们改变这一点。</p>
<p>We&#8217;ll take our component for handling user input and hide it behind an
interface. We&#8217;ll turn <code>InputComponent</code> into an abstract base class:</p>
<p>我们取出处理输入的部件，将其藏在接口之后。我们将<code>InputComponent</code>变为一个抽象基类。</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">InputComponent</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">InputComponent</span><span class="p">()</span> <span class="p">{}</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">update</span><span class="p">(</span><span class="n">Bjorn</span><span class="o">&amp;</span> <span class="n">bjorn</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>Then, we&#8217;ll take our existing user input handling code and push it down into a
class that implements that interface:</p>
<p>然后，我们将现有的处理输入的代码取出，放进一个实现接口的类中。</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">PlayerInputComponent</span> <span class="o">:</span> <span class="k">public</span> <span class="n">InputComponent</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">update</span><span class="p">(</span><span class="n">Bjorn</span><span class="o">&amp;</span> <span class="n">bjorn</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">Controller</span><span class="o">::</span><span class="n">getJoystickDirection</span><span class="p">())</span>
    <span class="p">{</span>
      <span class="k">case</span> <span class="nl">DIR_LEFT</span><span class="p">:</span>
        <span class="n">bjorn</span><span class="p">.</span><span class="n">velocity</span> <span class="o">-=</span> <span class="n">WALK_ACCELERATION</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>

      <span class="k">case</span> <span class="nl">DIR_RIGHT</span><span class="p">:</span>
        <span class="n">bjorn</span><span class="p">.</span><span class="n">velocity</span> <span class="o">+=</span> <span class="n">WALK_ACCELERATION</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">WALK_ACCELERATION</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>We&#8217;ll change <code>Bjorn</code> to hold a pointer to the input component instead of having
an inline instance:</p>
<p>我们将<code>Bjorn</code>改为只拥有一个指向输入组件的指针，而不是有一个内联的实例。</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">Bjorn</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="kt">int</span> <span class="n">velocity</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>

  <span class="n">Bjorn</span><span class="p">(</span><span class="n">InputComponent</span><span class="o">*</span> <span class="n">input</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">input_</span><span class="p">(</span><span class="n">input</span><span class="p">)</span>
  <span class="p">{}</span>

  <span class="kt">void</span> <span class="n">update</span><span class="p">(</span><span class="n">World</span><span class="o">&amp;</span> <span class="n">world</span><span class="p">,</span> <span class="n">Graphics</span><span class="o">&amp;</span> <span class="n">graphics</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">input_</span><span class="o">-&gt;</span><span class="n">update</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
    <span class="n">physics_</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">world</span><span class="p">);</span>
    <span class="n">graphics_</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">graphics</span><span class="p">);</span>
  <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="n">InputComponent</span><span class="o">*</span> <span class="n">input_</span><span class="p">;</span>
  <span class="n">PhysicsComponent</span> <span class="n">physics_</span><span class="p">;</span>
  <span class="n">GraphicsComponent</span> <span class="n">graphics_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>Now, when we instantiate <code>Bjorn</code>, we can pass in an input component for it to
use, like so:</p>
<p>现在但我们实例化<code>Bjorn</code>，我们可以传入一个输入组件使用，就像下面这样：</p>
<div class="codehilite"><pre><span class="n">Bjorn</span><span class="o">*</span> <span class="n">bjorn</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Bjorn</span><span class="p">(</span><span class="k">new</span> <span class="n">PlayerInputComponent</span><span class="p">());</span>
</pre></div>


<p>This instance can be any concrete type that implements our abstract
<code>InputComponent</code> interface. We pay a price for this&#8202;&mdash;&#8202;<code>update()</code> is now a virtual
method call, which is a little slower. What do we get in return for this cost?</p>
<p>这个实例可以是任何实现了抽象<code>InputComponent</code>接口的类型。我们为此付出了代价——<code>update()</code>现在是一个虚方法调用了，这会慢一些。这一代价的回报是什么？</p>
<p>Most consoles require a game to support &#8220;demo mode.&#8221; If the player sits at the
main menu without doing anything, the game will start playing automatically,
with the computer standing in for the player. This keeps the game from burning
the main menu into your TV and also makes the game look nicer when it&#8217;s running
on a kiosk in a store.</p>
<p>大多数的主机需要游戏支持“演示模式”。如果玩家停在主菜单没有做任何事情，游戏就会自动开始自动运行，等待电脑接入一个玩家。这让你电视上的主菜单看上去更有生机，同时也是在商店中很好的展示。</p>
<p>Hiding the input component class behind an interface lets us get that working.
We already have our concrete <code>PlayerInputComponent</code> that&#8217;s normally used when
playing the game. Now, let&#8217;s make another one:</p>
<p>隐藏在输入组件后的类帮我们实现了这一点，我们已经有了具体的<code>PlayerInputComponent</code>，供我们在玩游戏时使用。现在让我们完成另一个：</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">DemoInputComponent</span> <span class="o">:</span> <span class="k">public</span> <span class="n">InputComponent</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">update</span><span class="p">(</span><span class="n">Bjorn</span><span class="o">&amp;</span> <span class="n">bjorn</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// AI to automatically control Bjorn...</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>


<p>When the game goes into demo mode, instead of constructing Bj&oslash;rn like we did
earlier, we&#8217;ll wire him up with our new component:</p>
<p>当游戏进入演示模式，不像我们之前演示的那样构造Bj&oslash;rn，我们将它和一个新组件连接起来：</p>
<div class="codehilite"><pre><span class="n">Bjorn</span><span class="o">*</span> <span class="n">bjorn</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Bjorn</span><span class="p">(</span><span class="k">new</span> <span class="n">DemoInputComponent</span><span class="p">());</span>
</pre></div>


<p>And now, just by swapping out a component, we&#8217;ve got a fully functioning
computer-controlled player for demo mode. We&#8217;re able to reuse all of the other
code for Bj&oslash;rn&#8202;&mdash;&#8202;physics and graphics don&#8217;t even know there&#8217;s a difference.
Maybe I&#8217;m a bit strange, but it&#8217;s stuff like this that gets me up in the <span
name="coffee">morning</span>.</p>
<p>现在，只需要更改组件，我们有了为演示模式而设计的电脑控制的玩家。我们可以重用所有Bj&oslash;rn的代码——物理和图像都不知道这里有了变化。也许我有些奇怪，但这就是每天能让我从起床的事物。</p>
<aside name="coffee">
<p>That, and coffee. Sweet, steaming hot coffee.</p>
</aside>
<h3><a href="#no-bj&oslash;rn-at-all" name="no-bj&oslash;rn-at-all">No Bj&oslash;rn at all?</a></h3>
<h3><a href="#完全没有bj&oslash;rn？" name="完全没有bj&oslash;rn？">完全没有Bj&oslash;rn？</a></h3>
<p>If you look at our <code>Bjorn</code> class now, you&#8217;ll notice there&#8217;s nothing really
&#8220;Bj&oslash;rn&#8221; about it&#8202;&mdash;&#8202;it&#8217;s just a component bag. In fact, it looks like a pretty
good candidate for a base &#8220;game object&#8221; class that we can use for <em>every</em> object
in the game. All we need to do is pass in <em>all</em> the components, and we can build
any kind of object by picking and choosing parts like Dr. Frankenstein.</p>
<p>如果你现在看看我们的<code>Bj&amp;oslash;rn</code>类，你会意识到那里完全没有“Bj&oslash;rn”——那只是一个组件包。事实上，它是<em>每个</em>游戏中的对象都能继承的“游戏对象”基类的一个好后溴铵人。我们可以像佛兰肯斯坦一样通过挑选拼装部件构建任何对象。</p>
<p>Let&#8217;s take our two remaining concrete components&#8202;&mdash;&#8202;physics and graphics&#8202;&mdash;&#8202;and
hide them behind interfaces like we did with input:</p>
<p>让我们将剩下的两个具体组件——物理和图像——像我们对输入那样藏到接口之后。</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">PhysicsComponent</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">PhysicsComponent</span><span class="p">()</span> <span class="p">{}</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">update</span><span class="p">(</span><span class="n">GameObject</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">,</span> <span class="n">World</span><span class="o">&amp;</span> <span class="n">world</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">GraphicsComponent</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">GraphicsComponent</span><span class="p">()</span> <span class="p">{}</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">update</span><span class="p">(</span><span class="n">GameObject</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">,</span> <span class="n">Graphics</span><span class="o">&amp;</span> <span class="n">graphics</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>Then we re-christen <code>Bjorn</code> into a <span name="id">generic</span> <code>GameObject</code>
class that uses those interfaces:</p>
<p>然后我们将<code>Bj&amp;oslash;rn</code>改为一个使用这些接口的通用<code>GameObject</code>类。</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">GameObject</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="kt">int</span> <span class="n">velocity</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>

  <span class="n">GameObject</span><span class="p">(</span><span class="n">InputComponent</span><span class="o">*</span> <span class="n">input</span><span class="p">,</span>
             <span class="n">PhysicsComponent</span><span class="o">*</span> <span class="n">physics</span><span class="p">,</span>
             <span class="n">GraphicsComponent</span><span class="o">*</span> <span class="n">graphics</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">input_</span><span class="p">(</span><span class="n">input</span><span class="p">),</span>
    <span class="n">physics_</span><span class="p">(</span><span class="n">physics</span><span class="p">),</span>
    <span class="n">graphics_</span><span class="p">(</span><span class="n">graphics</span><span class="p">)</span>
  <span class="p">{}</span>

  <span class="kt">void</span> <span class="n">update</span><span class="p">(</span><span class="n">World</span><span class="o">&amp;</span> <span class="n">world</span><span class="p">,</span> <span class="n">Graphics</span><span class="o">&amp;</span> <span class="n">graphics</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">input_</span><span class="o">-&gt;</span><span class="n">update</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
    <span class="n">physics_</span><span class="o">-&gt;</span><span class="n">update</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">world</span><span class="p">);</span>
    <span class="n">graphics_</span><span class="o">-&gt;</span><span class="n">update</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">graphics</span><span class="p">);</span>
  <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="n">InputComponent</span><span class="o">*</span> <span class="n">input_</span><span class="p">;</span>
  <span class="n">PhysicsComponent</span><span class="o">*</span> <span class="n">physics_</span><span class="p">;</span>
  <span class="n">GraphicsComponent</span><span class="o">*</span> <span class="n">graphics_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<aside name="id">
<p>Some component systems take this even further. Instead of a <code>GameObject</code> that
contains its components, the game entity is just an ID, a number. Then, you
maintain separate collections of components where each one knows the ID of the
entity its attached to.</p>
<p>These <a href="http://en.wikipedia.org/wiki/Entity_component_system">entity component
systems</a> take decoupling
components to the extreme and let you add new components to an entity without
the entity even knowing. The <a href="data-locality.html" class="pattern">Data
Locality</a> chapter has more details.</p>
</aside>
<p>Our existing concrete classes will get renamed and implement those interfaces:</p>
<p>我们现有的具体类将被重命名并实现这些接口。</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">BjornPhysicsComponent</span> <span class="o">:</span> <span class="k">public</span> <span class="n">PhysicsComponent</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">update</span><span class="p">(</span><span class="n">GameObject</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">,</span> <span class="n">World</span><span class="o">&amp;</span> <span class="n">world</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// Physics code...</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">BjornGraphicsComponent</span> <span class="o">:</span> <span class="k">public</span> <span class="n">GraphicsComponent</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">update</span><span class="p">(</span><span class="n">GameObject</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">,</span> <span class="n">Graphics</span><span class="o">&amp;</span> <span class="n">graphics</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// Graphics code...</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>


<p>And now we can build an object that has all of Bj&oslash;rn&#8217;s original behavior without
having to actually create a class for him, just like this:</p>
<p>现在我们无需为Bj&oslash;rn建立具体类，就能构建拥有所有Bj&oslash;rn的行为的对象。</p>
<p><span name="factory"></span></p>
<div class="codehilite"><pre><span class="n">GameObject</span><span class="o">*</span> <span class="nf">createBjorn</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="n">GameObject</span><span class="p">(</span><span class="k">new</span> <span class="n">PlayerInputComponent</span><span class="p">(),</span>
                        <span class="k">new</span> <span class="n">BjornPhysicsComponent</span><span class="p">(),</span>
                        <span class="k">new</span> <span class="n">BjornGraphicsComponent</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>


<aside name="factory">
<p>This <code>createBjorn()</code> function is, of course, an example of the classic Gang of
Four <a class="gof-pattern" href="http://c2.com/cgi/wiki?FactoryMethod">Factory
Method</a> pattern.</p>
</aside>
<p>By defining other functions that instantiate <code>GameObjects</code> with different
components, we can create all of the different kinds of objects our game needs.</p>
<p>通过用不同组件实例化<code>GameObject</code>，我们可以构建游戏需要的任何组件。</p>
<h2><a href="#design-decisions" name="design-decisions">Design Decisions</a></h2>
<h2><a href="#设计决策" name="设计决策">设计决策</a></h2>
<p>The most important design question you&#8217;ll need to answer with this pattern is,
&#8220;What set of components do I need?&#8221; The answer there is going to depend on the
needs and genre of your game. The bigger and more complex your engine is, the
more finely you&#8217;ll likely want to slice your components.</p>
<p>这章中你最需要回答的设计问题是“我需要什么样的组件？”回答取决于你游戏的需求和风格。你的引擎越大越复杂，你就越想将它们划分成组件。</p>
<p>Beyond that, there are a couple of more specific options to consider:</p>
<p>除此之外，还有几个更具体的选项要回答：</p>
<h3><a href="#how-does-the-object-get-its-components" name="how-does-the-object-get-its-components">How does the object get its components?</a></h3>
<h3><a href="#对象如何获取组件？" name="对象如何获取组件？">对象如何获取组件？</a></h3>
<p>Once we&#8217;ve split up our monolithic object into a few separate component parts,
we have to decide who puts the parts back together.</p>
<p>我们一旦将单块对象分割为多个分离的组件部分，我们就需要决定谁将它们拼到一起。</p>
<ul>
<li>
<p><strong>If the object creates its own components:</strong></p>
</li>
<li>
<p><em>如果对象创建它的组件：</em></p>
<ul>
<li>
<p><em>It ensures that the object always has the components it needs.</em> You
    never have to worry about someone forgetting to wire up the right
    components to the object and breaking the game. The container object
    itself takes care of it for you.</p>
</li>
<li>
<p><em>这保证了对象总是能拿到他需要的组件。</em>你永远不必担心某人忘记连接正确的组件然后破坏了整个游戏。容器类自己会处理这个问题。</p>
</li>
<li>
<p><em>It&#8217;s harder to reconfigure the object.</em> One of the powerful features of
    this pattern is that it lets you build new kinds of objects simply by
    recombining components. If our object always wires itself with the same
    set of hard-coded components, we aren&#8217;t taking advantage of that
    flexibility.</p>
</li>
<li>
<p><em>重新设置对象比较困难</em>这个模式的一个强力特性就是让你只需要重新组合组件就可以创建新的对象。如果对象总是自己用硬编码的组件组装自己，我们就无法使用这个灵活度。</p>
</li>
</ul>
</li>
<li>
<p><strong>If outside code provides the components:</strong></p>
</li>
<li>
<p><em>如果外部代码提供组件：</em></p>
<ul>
<li>
<p><em>The object becomes more flexible.</em> We can completely change the
    behavior of the object by giving it different components to work with.
    Taken to its fullest extent, our object becomes a generic component
    container that we can reuse over and over again for different purposes.</p>
</li>
<li>
<p><em>对象更加灵活。</em>我们可以改变不同的组件，这样就能改变对象的行为。通过通用组件，我们的对象变成了一个组件容器，我们可以一遍又一遍的为不同目的重用它。</p>
</li>
<li>
<p><em>The object can be decoupled from the concrete component types.</em> If
    we&#8217;re allowing outside code to pass in components, odds are good that
    we&#8217;re also letting it pass in <em>derived</em> component types. At that point,
    the object only knows about the component <em>interfaces</em> and not the
    concrete types themselves. This can make for a nicely encapsulated
    architecture.</p>
</li>
<li>
<p><em>对象可以与确定的组件类型解耦。</em>乳沟我们允许外部代码提供组件，好处是我们也可以传递<em>派生</em>的组件类型。这样，对象只知道组件的<em>接口</em>而不知道组件的具体类型。这是一个很好的封装结构。</p>
</li>
</ul>
</li>
</ul>
<h3><a href="#how-do-components-communicate-with-each-other" name="how-do-components-communicate-with-each-other">How do components communicate with each other?</a></h3>
<h3><a href="#组件之间如何通信？" name="组件之间如何通信？">组件之间如何通信？</a></h3>
<p>Perfectly decoupled components that function in isolation is a nice ideal, but
it doesn&#8217;t really work in practice. The fact that these components are part of the
<em>same</em> object implies that they are part of a larger whole and need to
coordinate. That means communication.</p>
<p>完美解耦的组件不需要考虑这个问题，但在真正的实践中行不通。事实上组件属于<em>同一个</em>对象暗示了他们属于更大整体的一部分，需要相互协同。这就意味着通信。</p>
<p>So how can the components talk to each other? There are a couple of options, but
unlike most design &#8220;alternatives&#8221; in this book, these aren&#8217;t exclusive&#8202;&mdash;&#8202;you will
likely support more than one at the same time in your designs.</p>
<p>所以组件如何相互通信呢？这里有很多选项，但不像这本书中其他的“选项”，他们并不冲突——你可能在一个设计中支持多种方案。</p>
<ul>
<li>
<p><strong>By modifying the container object&#8217;s state:</strong></p>
</li>
<li>
<p><em>通过修改容器对象的状态：</em></p>
<ul>
<li>
<p><em>It keeps the components decoupled.</em> When our <code>InputComponent</code> set
    Bj&oslash;rn&#8217;s velocity and the <code>PhysicsComponent</code> later used it, the two
    components had no idea that the other even existed. For all they knew,
    Bj&oslash;rn&#8217;s velocity could have changed through black magic.</p>
</li>
<li>
<p><em>这让组件解耦。</em>当我们的<code>InputComponent</code>设置了Bj&oslash;rn的速度，而后<code>PhysicsComponent</code>使用它，这两个组件都不知道对方的存在。他们的理解中，Bj&oslash;rn的速度是被黑魔法改变的。</p>
</li>
<li>
<p><em>It requires any information that components need to share to get pushed
    up into the container object.</em> Often, there&#8217;s state that&#8217;s really only
    needed by a subset of the components. For example, an animation and a
    rendering component may need to share information that&#8217;s
    graphics-specific. Pushing that information up into the container object
    where <em>every</em> component can get to it muddies the object class.</p>
</li>
<li>
<p><em>他需要将更多组件需要分享的数据存储在容器类中。</em>通常状态只有几个组件需要共享。比如，一个动画组件和一个渲染组件需要共享图形专用的信息。将信息存入容器类会让<em>所有</em>组件都能获得这样的信息。</p>
<p>Worse, if we use the same container object class with different
component configurations, we can end up wasting memory on state that
isn&#8217;t needed by <em>any</em> of the object&#8217;s components. If we push some
rendering-specific data into the container object, any invisible object
will be burning memory on it with no benefit.</p>
<p>更糟的是，如果我们用不同组件设置构建的相同容器类，我们最终会浪费内存存储没有<em>任何</em>对象组件需要的状态。如果我们将渲染专用的数据放入容器对象中，任何隐形对象都会无益的消耗内存。</p>
</li>
<li>
<p><em>It makes communication implicit and dependent on the order that
    components are processed.</em> In our sample code, the original monolithic
    <code>update()</code> method had a very carefully laid out order of operations. The
    user input modified the velocity, which was then used by the physics
    code to modify the position, which in turn was used by the rendering
    code to draw Bj&oslash;rn at the right spot. When we split that code out into
    components, we were careful to preserve that order of operations.</p>
</li>
<li>
<p><em>这让组件的通信基于组件运行的顺序。</em>在同样 的代码中原先一整块的<code>update()</code>代码小心的排列这些笑傲做。玩家的输入修改了速度，速度被物理代码使用修改位置，位置被渲染代码使用将Bj&oslash;rn画到该有的地方。当我们将这些代码划入组件时，我们还是得小心翼翼的保持这种操作顺序。</p>
<p>If we hadn&#8217;t, we would have introduced <span name="pure">subtle</span>,
hard-to-track bugs. For example, if we&#8217;d updated the graphics component
<em>first</em>, we would wrongly render Bj&oslash;rn at his position on the <em>last</em>
frame, not this one. If you imagine several more components and lots
more code, then you can get an idea of how hard it can be to avoid bugs
like this.</p>
<p>如果我们没有，我们就引入了微妙而难以追踪的漏洞。比如，我们<em>先</em>更新图形组件，我们就错误的将Bj&oslash;rn渲染再来他<em>上一帧</em>所处的位置上，而不是这一帧的。如果你考虑更多的组件和更多的代码，那你就可以想象要避免这样的漏洞有多么困难了。</p>
<aside name="pure">

<p>Shared mutable state like this where lots of code is reading and writing
the same data is notoriously hard to get right. That&#8217;s a big part of why
academics are spending time researching pure functional languages like
Haskell where there is no mutable state at all.</p>
</aside>

</li>
</ul>
</li>
<li>
<p><strong>By referring directly to each other:</strong></p>
</li>
<li>
<p><em>通过他们之间相互引用：</em></p>
<p>The idea here is that components that need to talk will have direct
references to each other without having to go through the container
object at all.</p>
<p>这里的想法是组件有他们需要交流组件的引用，这样他们就直接交流，无需通过容器类。</p>
<p>Let&#8217;s say we want to let Bj&oslash;rn jump. The graphics code needs to know if
he should be drawn using a jump sprite or not. It can determine this by
asking the physics engine if he&#8217;s currently on the ground. An easy way
to do this is by letting the graphics component know about the physics
component directly:</p>
<p>假设哦我们想让Bj&oslash;rn跳跃。图像代码想要知道他需要使用一个单独的跳跃图像还是不用。这可以通过询问物理引擎它现在在不在地上来确定。一种简单的方式是图像组件直接指导物理组件的存在：</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">BjornGraphicsComponent</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">BjornGraphicsComponent</span><span class="p">(</span><span class="n">BjornPhysicsComponent</span><span class="o">*</span> <span class="n">physics</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">physics_</span><span class="p">(</span><span class="n">physics</span><span class="p">)</span>
  <span class="p">{}</span>

  <span class="kt">void</span> <span class="n">Update</span><span class="p">(</span><span class="n">GameObject</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">,</span> <span class="n">Graphics</span><span class="o">&amp;</span> <span class="n">graphics</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">Sprite</span><span class="o">*</span> <span class="n">sprite</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">physics_</span><span class="o">-&gt;</span><span class="n">isOnGround</span><span class="p">())</span>
    <span class="p">{</span>
      <span class="n">sprite</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">spriteJump_</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
      <span class="c1">// Existing graphics code...</span>
    <span class="p">}</span>

    <span class="n">graphics</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="o">*</span><span class="n">sprite</span><span class="p">,</span> <span class="n">obj</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">obj</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
  <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="n">BjornPhysicsComponent</span><span class="o">*</span> <span class="n">physics_</span><span class="p">;</span>

  <span class="n">Sprite</span> <span class="n">spriteStand_</span><span class="p">;</span>
  <span class="n">Sprite</span> <span class="n">spriteWalkLeft_</span><span class="p">;</span>
  <span class="n">Sprite</span> <span class="n">spriteWalkRight_</span><span class="p">;</span>
  <span class="n">Sprite</span> <span class="n">spriteJump_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>When we construct Bj&oslash;rn&#8217;s <code>GraphicsComponent</code>, we&#8217;ll give it a reference
to his corresponding <code>PhysicsComponent</code>.</p>
<p>但我们构建Bj&oslash;rn的<code>GraphicsComponent</code>时，我们给他一个对应的<code>PhysicsComponent</code>引用。</p>
<ul>
<li>
<p><em>It&#8217;s simple and fast.</em> Communication is a direct method call from one
    object to another. The component can call any method that is supported
    by the component it has a reference to. It&#8217;s a free-for-all.</p>
</li>
<li>
<p><em>简单快捷。</em>通信是一个对象到另一个的直接方法调用。组件可以调用任何一个引用对象的方法。什么都可以。</p>
</li>
<li>
<p><em>The two components are tightly coupled.</em> The downside of the
    free-for-all. We&#8217;ve basically taken a step back towards our monolithic
    class. It&#8217;s not quite as bad as the original single class though, since
    we&#8217;re at least restricting the coupling to only the component pairs that
    need to interact.</p>
</li>
<li>
<p><em>两个组件紧紧绑在了一起。</em>什么都可以的坏处。我们向使用一整块类又退回来一步。这比只用单一类好一点，至少我们现在只是把需要通信的类绑在了一起。</p>
</li>
</ul>
</li>
<li>
<p><strong>By sending messages:</strong></p>
</li>
<li>
<p><em>通过发送消息：</em></p>
<ul>
<li>
<p>This is the most complex alternative. We can actually build a little
    messaging system into our container object and let the components
    broadcast information to each other.</p>
</li>
<li>
<p>这是最复杂的选项。我们可以在我们的容器类中建一个小小的消息系统，允许组件相互发送消息。</p>
<p>Here&#8217;s one possible implementation. We&#8217;ll start by defining a base
<code>Component</code> interface that all of our components will implement:</p>
<p>这是一种可能的实现。我们从每个组件都会实现的<code>Component</code>接口开始：</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">Component</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">Component</span><span class="p">()</span> <span class="p">{}</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">receive</span><span class="p">(</span><span class="kt">int</span> <span class="n">message</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>It has a single <code>receive()</code> method that component classes implement in
order to listen to an incoming message. Here, we&#8217;re just using an <code>int</code>
to identify the message, but a fuller implementation could attach
additional data to the message.</p>
<p>它有一个简单的<code>receive()</code>方法，每一个需要接受消息的类都要实现它。这里，我们使用一个<code>int</code>来定义消息。但更全面的消息实现应该可以引用附加的消息。</p>
<p>Then, we&#8217;ll add a method to our container object for sending messages:</p>
<p>然后，我们向容器类添加发送消息的方法。</p>
<div class="codehilite"><pre><span class="k">class</span> <span class="nc">ContainerObject</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="kt">void</span> <span class="n">send</span><span class="p">(</span><span class="kt">int</span> <span class="n">message</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_COMPONENTS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">components_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
      <span class="p">{</span>
        <span class="n">components_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">receive</span><span class="p">(</span><span class="n">message</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">MAX_COMPONENTS</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
  <span class="n">Component</span><span class="o">*</span> <span class="n">components_</span><span class="p">[</span><span class="n">MAX_COMPONENTS</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>


<p><span name="queue">Now</span>, if a component has access to its
container, it can send messages to the container, which will
rebroadcast the message to all of the contained components. (That
includes the original component that sent the message; be careful that
you don&#8217;t get stuck in a feedback loop!) This has a couple of
consequences:</p>
<p>现在，如果组件能够接触容器，他就能向容器发送消息，浙江向所有的组件广播。（包括了原先发送消息的组件，小心别陷入消息的无限循环中！）这会有一些结果：</p>
<aside name="queue">

<p>If you really want to get fancy, you can even make this message system
<em>queue</em> messages to be delivered later. For more on this, see <a
href="event-queue.html" class="pattern">Event Queue</a>.</p>
</aside>

</li>
<li>
<p><em>Sibling components are decoupled.</em> By going <span
    name="mediator">through</span> the parent container object, like our
    shared state alternative, we ensure that the components are still
    decoupled from each other. With this system, the only coupling they have
    is the message values themselves.</p>
</li>
<li>
<p><em>同级组件解耦</em>通过父级容器对象，就像我们共享状态的方案一样，我们保证了组件之间仍然是解耦的。使用了这套系统，组件之间唯一的耦合是他们发送的消息值。</p>
<aside name="mediator">

<p>The Gang of Four call this the <a class="gof-pattern"
href="http://c2.com/cgi-bin/wiki?MediatorPattern">Mediator</a> pattern &#8212;
two or more objects communicate with each other indirectly by routing
the message through an intermediate object. In this case, the container
object itself is the mediator.</p>
</aside>

</li>
<li>
<p><em>The container object is simple.</em> Unlike using shared state where the
    container object itself owns and knows about data used by the
    components, here, all it does is blindly pass the messages along. That
    can be useful for letting two components pass very domain-specific
    information between themselves without having that bleed into the
    container object.</p>
</li>
<li>
<p><em>容器类很简单。</em>不像使用共享状态那样，容器类自己无需知道组件使用了什么数据，它只是将消息发送出去。这可以让组件发送领域特有的数据而无需打扰容器对象。</p>
</li>
</ul>
</li>
</ul>
<p>Unsurprisingly, there&#8217;s no one best answer here. What you&#8217;ll likely end up doing
is using a bit of all of them. Shared state is useful for the really basic stuff
that you can take for granted that every object has&#8202;&mdash;&#8202;things like position and
size.</p>
<p>不出意料的，这里没有最好的回答。这些你最终可能都会使用一些。共享状态对于每一个对象都有的数据是很好用的——比如位置和大小。</p>
<p>Some domains are distinct but still closely related. Think animation and
rendering, user input and AI, or physics and collision. If you have separate
components for each half of those pairs, you may find it easiest to just let
them know directly about their other half.</p>
<p>有些领域不同却仍然紧密相关。想想动画和渲染，用户输入和AI，或者物理和粒子。如果你有这样一对分离的组件，你会发现直接拥有相互引用也许更加容易。</p>
<p>Messaging is useful for &#8220;less important&#8221; communication. Its fire-and-forget
nature is a good fit for things like having an audio component play a sound when
a physics component sends a message that the object has collided with something.</p>
<p>消息对于“不那么重要”的通信很有用。发送后不管的特性对于物理组件发现事物碰撞后发送消息，让音乐组件播放声音这种事情是很有效的。</p>
<p>As always, I recommend you start simple and then add in additional
communication paths if you need them.</p>
<p>就像以前一样，我建议你从简单的开始，然后如果需要的话，加入其他的通信路径。</p>
<h2><a href="#see-also" name="see-also">See Also</a></h2>
<h2><a href="#参见" name="参见">参见</a></h2>
<ul>
<li>
<p>The <a href="http://unity3d.com">Unity</a> framework&#8217;s core <a href="http://docs.unity3d.com/Documentation/Manual/GameObjects.html"><code>GameObject</code></a> class is designed
    entirely around <a href="http://docs.unity3d.com/Manual/UsingComponents.html">components</a>.</p>
</li>
<li>
<p><a href="http://unity3d.com">Unity</a>核心架构中<a href="http://docs.unity3d.com/Documentation/Manual/GameObjects.html"><code>GameObject</code></a>类完全根据这样的原则设计 <a href="http://docs.unity3d.com/Manual/UsingComponents.html">components</a>。</p>
</li>
<li>
<p>The open source <a href="http://www.delta3d.org">Delta3D</a> engine has a base
    <code>GameActor</code> class that implements this pattern with the appropriately named
    <code>ActorComponent</code> base class.</p>
</li>
<li>
<p>开源的<a href="http://www.delta3d.org">Delta3D</a>引擎有一个<code>GameActor</code>基类通过<code>ActorComponent</code>基类实现了这种模式。</p>
</li>
<li>
<p>Microsoft&#8217;s <a href="http://creators.xna.com/en-US/">XNA</a> game framework
    comes with a core <code>Game</code> class. It owns a collection of <code>GameComponent</code>
    objects. Where our example uses components at the individual game entity
    level, XNA implements the pattern at the level of the main game object
    itself, but the purpose is the same.</p>
</li>
<li>
<p>微软的<a href="http://creators.xna.com/en-US/">XNA</a>游戏框架有一个核心的<code>Game</code>类。他拥有一系列<code>GameComponent</code>对象。我们在游戏实体层使用组件，XNA在游戏主对象上实现了这种模式，但意图是一样的。</p>
</li>
<li>
<p>This pattern bears resemblance to the Gang of Four&#8217;s <a class="gof-pattern"
    href="http://c2.com/cgi-bin/wiki?StrategyPattern">Strategy</a> pattern. Both
    patterns are about taking part of an object&#8217;s behavior and delegating it to
    a separate subordinate object. The difference is that with the Strategy
    pattern, the separate &#8220;strategy&#8221; object is usually stateless&#8202;&mdash;&#8202;it
    encapsulates an algorithm, but no data. It defines <em>how</em> an object behaves,
    but not <em>what</em> it is.</p>
<p>这种模式与GoF的<a class="gof-pattern" href="http://c2.com/cgi-bin/wiki?StrategyPattern">策略模式</a> 类似。两种模式都是将对象的行为取出划入一个单独的重述对象。与对象模式不同的是，分离的策略模式通常是无状态的——它分装了算法，而没有数据。他定义了对象<em>如何</em>行动，但没有定义对象<em>是</em>什么。</p>
<p>Components are a bit more self-important. They often hold state that
describes the object and helps define its actual identity. However, the line
may blur. You may have some components that don&#8217;t need any local state. In
that case, you&#8217;re free to use the same component <em>instance</em> across multiple
container objects. At that point, it really is behaving more akin to a
strategy.</p>
<p>组件本身更加重要。他们经常保存了描述对象的状态，这有助于确定其真正的身份。但是，这条线很模糊。你也许有一些组件根本没有任何状态。在这种情况下，你可以在不同的容器对象中使用相同的组件<em>实例</em>。这样看来，他的行为看上去确实更像一种策略。</p>
</li>
</ul>
<nav>
  <span class="prev">&larr; <a href="decoupling-patterns.html">Previous Chapter</a></span>
  <span class="next"><a href="event-queue.html">Next Chapter</a> &rarr;</span>
  <span class="toc">&equiv; <a href="/">The Book</a></span>
</nav>
</div>
</div>
<footer>&copy; 2009-2015 Robert Nystrom</footer>
</body>
</html>
